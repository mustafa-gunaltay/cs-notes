

# 0) Coklu Akis Yonetimi nedir

### 📘 1. Kavramsal Tanım

Gerçek bir uygulamada genelde **birden fazla veri kaynağı (stream)** vardır:
örneğin,

* bir **kullanıcının seçimleri (dropdown, checkbox, input)**
* bir **API yanıtı (HTTP Observable)**
* veya bir **timer / sensör akışı**

Bu akışlar **bağımsız** ama **birbiriyle ilişkili** olabilir.
İşte `combineLatest()` gibi operatörler, bu birden fazla akışı **senkronize edip tek bir birleşik akış** haline getirir.

> 💡 **Soyut tanım:**
> “Birden fazla veri kaynağını aynı zaman ekseninde hizala.”

---




# 1) combineLatest

### 📘 1. Kavramsal Tanım

Gerçek bir uygulamada genelde **birden fazla veri kaynağı (stream)** vardır:
örneğin,

* bir **kullanıcının seçimleri (dropdown, checkbox, input)**
* bir **API yanıtı (HTTP Observable)**
* veya bir **timer / sensör akışı**

Bu akışlar **bağımsız** ama **birbiriyle ilişkili** olabilir.
İşte `combineLatest()` gibi operatörler, bu birden fazla akışı **senkronize edip tek bir birleşik akış** haline getirir.

> 💡 **Soyut tanım:**
> “Birden fazla veri kaynağını aynı zaman ekseninde hizala.”

---

### ⚙️ 2. Temel Kullanım

```ts
import { combineLatest, of } from 'rxjs';
import { map } from 'rxjs/operators';

const name$ = of('Mustafa');
const age$ = of(22);

combineLatest([name$, age$])
  .pipe(map(([name, age]) => `${name} is ${age} years old`))
  .subscribe(console.log);
```

🧠 **Açıklama:**

* Her Observable (`name$`, `age$`) bir değer *emit* eder.
* `combineLatest()` → her biri yeni değer ürettiğinde, **tüm son değerleri alır** ve bir **dizi olarak** döner.
* Bu dizi (`[name, age]`) `map()` ile birleştirilip tek bir anlamlı çıktı haline gelir.

📤 **Çıktı:**

```
Mustafa is 22 years old
```

---

### 🔄 3. Reaktif Akış Mantığı

```
name$   :   Mustafa ────────→
age$    :   22 ─────────────→
combine :   [Mustafa, 22] ──→ map() → "Mustafa is 22 years old"
```

> Yani, her akış kendi zamanında çalışsa bile,
> `combineLatest()` onları **en son değerleriyle** senkronize eder.

---

### ⚡ 4. Gerçek Hayat Örneği (Angular)

```ts
combineLatest([
  this.selectedCategory$,
  this.categoryService.getProducts()
]).pipe(
  map(([category, products]) =>
    products.filter(p => p.categoryId === category.id)
  )
).subscribe(filtered => this.displayedProducts = filtered);
```

🧠 **Ne oluyor:**

* Kullanıcı kategori seçtiğinde `selectedCategory$` yeni bir değer *emit* ediyor.
* API’den ürün listesi geldiğinde `getProducts()` yeni bir değer *emit* ediyor.
* `combineLatest()` bu iki akışı **senkronize ediyor** →
  yeni kategori seçildiğinde veya ürün listesi yenilendiğinde görünüm (UI) reaktif olarak güncelleniyor.

---

### ✅ 5. Best Practice’ler

| Prensip                                                                                | Açıklama                                                                                   |
| -------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| **1. combineLatest yalnızca her Observable en az bir kez emit ettikten sonra çalışır** | Yani başlangıçta hiçbir değer yoksa tetiklenmez.                                           |
| **2. `map()` veya `switchMap()` ile birlikte kullan**                                  | Böylece veriyi dönüştürüp UI’a uygun hale getirebilirsin.                                  |
| **3. `startWith()` ekleyerek ilk değeri garanti et**                                   | Boş durumlarda UI’in donmaması için.                                                       |
| **4. Tek sorumluluk**                                                                  | combineLatest yalnızca “eşzamanlama” için kullanılmalı, dönüşüm işi `map()`’e bırakılmalı. |

---

### 💡 Soyutlama Cümlesi

> “`combineLatest()` reaktif sistemin senkronizasyon katmanıdır.
> Birden fazla bağımsız akışı aynı anda izler,
> ve her biri yeni değer ürettiğinde birleşik bir tepki (reaksiyon) oluşturur.”

---




### Gercek Hayat Ornegi

```ts
export default class ArticleComponent implements OnInit {
  article!: Article;
  currentUser!: User | null;
  comments: Comment[] = [];
  canModify: boolean = false;

  commentControl = new FormControl<string>("", { nonNullable: true });
  commentFormErrors: Errors | null = null;

  isSubmitting = false;
  isDeleting = false;
  destroyRef = inject(DestroyRef);

  constructor(
    private readonly route: ActivatedRoute,
    private readonly articleService: ArticlesService,
    private readonly commentsService: CommentsService,
    private readonly router: Router,
    private readonly userService: UserService,
  ) {}

  ngOnInit(): void {
    const slug = this.route.snapshot.params["slug"];
    combineLatest([
      this.articleService.get(slug),
      this.commentsService.getAll(slug),
      this.userService.currentUser,
    ])
      .pipe(
        catchError((err) => {
          void this.router.navigate(["/"]);
          return throwError(() => err);
        }),
        takeUntilDestroyed(this.destroyRef),
      )
      .subscribe(([article, comments, currentUser]) => {
        this.article = article;
        this.comments = comments;
        this.currentUser = currentUser;
        this.canModify = currentUser?.username === article.author.username;
      });
  }

...
}
```

- Gercek hayattaki bir makale sayfasi -> makale verisi, makale yorumları ve mevcut kullanıcı bir butundur. Dolayisiyla bunlardan herhangi biri degistiginde hepsinin ayni anda guncellenmesi ( birbirine bagli sekilde handle edilmesi) gerekir. 
- Ornegin makale (slug) değişirse, makale verisi ve o makalenin yorumları yeniden yüklenmelidir. 






# 2) forkJoin

---

## ✅ `forkJoin` nedir?

`forkJoin`, **tüm Observable’lar tamamlandığında** (complete olduğunda) **tek bir sonuç** döndüren bir RxJS operatörüdür.

📌 Yani:

* “Hepsi bitsin, öyle devam edelim” senaryosu için kullanılır.
* Promise’lerdeki `Promise.all` yapısının **RxJS karşılığıdır**.
* En sık **çoklu HTTP isteği yapıp sonuçları birleştirmek** için kullanılır.

---

## ✅ `forkJoin` nasıl çalışır?

* İçine verdiğin her Observable'ın **bitmesini bekler**.
* Her Observable’ın **son değerini** alır.
* **Tek sefer** değer yayınlar ve **tamamlanır**.

---

## ✅ Kullanımı

### 👍 En basit örnek

```ts
import { forkJoin } from 'rxjs';

forkJoin([
  of(1),
  of(2),
  of(3)
]).subscribe(result => {
  console.log(result); // [1, 2, 3]
});
```

### ✅ Gerçek kullanım – çoklu HTTP isteği

```ts
forkJoin({
  user: this.http.get('/api/user/10'),
  posts: this.http.get('/api/user/10/posts'),
  comments: this.http.get('/api/user/10/comments'),
}).subscribe(result => {
  console.log(result.user);
  console.log(result.posts);
  console.log(result.comments);
});
```

---

## ⚠️ Önemli özellikler

| Özellik                | Açıklama                                                     |
| ---------------------- | ------------------------------------------------------------ |
| **Tek yayın yapar**    | Hepsi bitince 1 kez emit eder                                |
| **Completion zorunlu** | Eğer bir Observable hiç `complete` etmezse forkJoin çalışmaz |
| **Son değerleri alır** | Observable’ların sadece *en son değerini* alır               |
| **HTTP ile uyumlu**    | Çünkü HTTP istekleri zaten `complete` olur                   |

---


## 🎯 Senaryo (forkJoin ve combineLatest icin ayni örnek)

Bir e-ticaret uygulaması düşünelim. Kullanıcı bir ürün sayfasına girdiğinde:

✅ 2 API çağrısı yapılacak:

1. `getProduct()` → Ürünün detaylarını getirir
2. `getStock()` → Ürünün stok bilgisini getirir

```ts
getProduct(id) // Örn: { id: 10, name: "Laptop", price: 15000 }
getStock(id)   // Örn: { productId: 10, inStock: true }
```

---

### ✅ forkJoin ile kullanım (HTTP için ideal)

```ts
forkJoin({
  product: this.api.getProduct(10),
  stock: this.api.getStock(10)
}).subscribe(result => {
  console.log('Ürün:', result.product);
  console.log('Stok:', result.stock);
});
```

#### ✅ Ne olur?

| Özellik             | forkJoin davranışı                                           |
| ------------------- | ------------------------------------------------------------ |
| Ne zaman çalışır?   | Her iki istek **bitince**                                    |
| Kaç kere emit eder? | **1 kez**                                                    |
| Use case            | İlk yükleme – sayfayı açarken ihtiyacımız olan final veri    |
| Uygun mu?           | ✅ Çok uygun – HTTP istekleri zaten 1 kez döner ve tamamlanır |

---

### 🔄 combineLatest ile aynı senaryo

```ts
combineLatest({
  product: this.api.getProduct(10),
  stock: this.api.getStock(10)
}).subscribe(result => {
  console.log('Ürün:', result.product);
  console.log('Stok:', result.stock);
});
```

#### ❗ Ne olur?

| Özellik             | combineLatest davranışı                              |
| ------------------- | ---------------------------------------------------- |
| Ne zaman çalışır?   | Her iki stream **ilk değerini ürettikten sonra**     |
| Kaç kere emit eder? | **Her yeni değer geldiğinde tekrar**                 |
| Use case            | Genelde **sürekli güncellenen veri** akışı           |
| Uygun mu?           | ❌ HTTP için mantıksız – çünkü HTTP tekrar etmez      |
| Sorun               | `stock` tekrar değişmezse combineLatest sessiz kalır |

---


## ❗ Davranis Farki Ozeti

| Özellik          | `forkJoin`                          | `combineLatest`                                   |
| ---------------- | ----------------------------------- | ------------------------------------------------- |
| Publish zamanı   | Tüm kaynaklar bitince **tek sefer** | İlk değerlerden sonra **her değişimde emit eder** |
| Kullanım amacı   | “Hepsi bitsin, sonucu birleştir”    | “Son durumları birlikte takip et”                 |
| Completion şartı | Evet, hepsi complete olmalı         | Hayır                                             |
| Değer tipi       | Son değerleri verir                 | En güncel değerleri sürekli verir                 |
| Yayın sayısı     | 1                                   | Sürekli                                           |
| En iyi kullanım  | Çoklu HTTP                          | Form birleşimi, UI state, reaktif hesaplama       |

---


## 👇 Özet cümle

> ✅ **`forkJoin` = Promise.all gibi → "Hepsi bitsin, sonucu ver"**

> 🔄 **`combineLatest` = "Hangisi değişirse değişsin, en son halleri birlikte ver"**

---







# 3) Diğer Çoklu Akış Yönetim Mekanizmaları

Bu başlık altına **combineLatest** ve **forkJoin** dışında kalan önemli RxJS operatörlerini ekleyebiliriz. Hepsi "multiple observable streams" yani **çoklu observable akışlarını yönetme stratejileri** altında toplanır. 

---

### 🔧 3.1 `zip`

**Ne yapar?**
Birden fazla observable’dan gelen verileri **sıra numaralarına göre eşleştirir**. Yani her akıştan **aynı index’teki değerleri** birleştirir.

**En iyi kullanım alanı:**
Senkron eşleşen veri işlemleri – örneğin: kullanıcı isimleri + kullanıcı yaşları iki ayrı akıştan geliyorsa index’e göre eşleştirilebilir.

---

### 🔁 3.2 `merge`

**Ne yapar?**
Birden fazla observable’ı **tek observable gibi birleştirir**, veriler **hangisinden gelirse gelsin tek stream** olarak akar.

**En iyi kullanım alanı:**
Birden fazla kaynaktan veri akıyorsa ve **sıra önemli değilse**, akışları birleştirmek için.

---

### 🔀 3.3 `concat`

**Ne yapar?**
Observable’ları **sırasıyla** çalıştırır. İlk observable tamamlanmadan diğerine geçmez.

**En iyi kullanım alanı:**
**Adım adım ardışık süreçler** – örneğin önce kullanıcı login olacak, sonra profil yüklenecek.

---

### ⚡ 3.4 `switchMap`

**Ne yapar?**
Yeni bir akış başlatıldığında **öncekini iptal eder**.

**En iyi kullanım alanı:**
**Arama kutusu (autocomplete)** gibi sürekli değişen isteklerde eski istekleri iptal etmek için.

---

### 🔁 3.5 `mergeMap` (flatMap)

**Ne yapar?**
Gelen her veriye karşılık **eşzamanlı yeni bir observable başlatır** ve hepsini tek akışta toplar. Paralel çalışır.

**En iyi kullanım alanı:**
Aynı anda **çoklu paralel HTTP istekleri** veya event işleme.

---

### 🔗 3.6 `concatMap`

**Ne yapar?**
Gelen her veriyi **sırayla** işler, önceki bitmeden yenisini başlatmaz.

**En iyi kullanım alanı:**
**Kuyruklama işlemleri** – Örn: sipariş işlemleri sırayla işlenmeli.

---

### ❗ 3.7 `exhaustMap`

**Ne yapar?**
Bir işlem sürerken **yeni gelen istekleri yok sayar**.

**En iyi kullanım alanı:**
**Butona spam tıklama engellemek** – bir HTTP isteği sürerken diğerlerini görmezden gelir.

---

### ✅ Özet Tablo

| Operatör      | Amaç                             | Sıra Garantisi | Paralel | Özel Davranış                |
| ------------- | -------------------------------- | -------------- | ------- | ---------------------------- |
| combineLatest | En son değerleri birleştirir     | ❌              | ✅       | Hepsi en az 1 değer üretmeli |
| forkJoin      | Son değerler tamamlanınca        | ✅              | ✅       | Observable’lar bitmeli       |
| zip           | Index’e göre eşleştirir          | ✅              | ✅       | Aynı sıra ile                |
| merge         | Akışları birleştirir             | ❌              | ✅       | Çakışan akışlar              |
| concat        | Sıra ile çalıştırır              | ✅              | ❌       | İlk bitmeden diğerine geçmez |
| switchMap     | Önceki iptal edilir              | ❌              | ✅       | Autocomplete için ideal      |
| mergeMap      | Hepsini paralel çalıştırır       | ❌              | ✅       | Çoklu HTTP paralel           |
| concatMap     | Sırayla çalıştırır               | ✅              | ❌       | Kuyruklama için              |
| exhaustMap    | Devam ederken yenisini yok sayar | ❌              | ❌       | Spam işlem engelleme         |

---



# 4) Coklu Akis Yonetimi Yapilari Hizli Notlar

## 1) switchMap
```ts
this.userService.currentUser
      .pipe(
        // currentUser her degistiginde null mi diye kontrol et 
        // (herhangi bir kullanici login degilse ayni null'sa) ise 
        // kategorileri temizle
        filter((user) => {
          // Kullanıcı yoksa (logout durumu) kategorileri temizle
          if (!user) {
            this.logger.warn('Kullanıcı bilgisi yok, kategoriler temizleniyor', {}, 'CategoryListComponent');
            this.categories = [];
            this.currentUser = null;
            this.loading = false;
          }
          return !!user; // Sadece user varsa devam et
        }),
        // currentUser her değiştiğinde currentUser seklinde akan stream'i 
        // "this.categoryService.getCategoriesByUserId(currentUser.id)" den
        // donen stream ile degistir. 
        // Eski currentUser stream'i iptal edilir ve yerine 
        // yeni kategori stream'i gelerek stream devam eder
        // Ornegin catchError kategori stream'inden gelen hatalari yakalar
        switchMap((currentUser) => {
          // currentUser state'ini güncelle
          this.currentUser = currentUser;
          
          this.logger.debug('CurrentUser alındı, kategoriler yükleniyor', { 
            userId: currentUser.id, 
            email: currentUser.email 
          }, 'CategoryListComponent');
          
          // userId ile kategorileri yükle
          return this.categoryService.getCategoriesByUserId(currentUser.id);
        }),
        catchError((err) => {
          this.logger.error('Veri yükleme hatası', { error: err }, 'CategoryListComponent');
          this.errors = this.errorHandler.handleHttpError(err);
          this.loading = false;
          return throwError(() => err);
        }),
        takeUntilDestroyed(this.destroyRef)
      )
      .subscribe({
        next: (categories) => {
          this.logger.info('Veriler başarıyla yüklendi', { 
            count: categories.length,
            userId: this.currentUser?.id 
          }, 'CategoryListComponent');
          
          this.categories = categories;
          this.loading = false;
        },
        error: (error) => {
          this.logger.error('Subscribe error', { error }, 'CategoryListComponent');
          this.loading = false;
        }
      });
```


`switchMap`'i anlamanın en iyi yolu, onu "haritalamak" (map) ve "değiştirmek/geçiş yapmak" (switch) olarak iki parçada düşünmektir.

* **Map (Haritalama) Kısmı:** Tıpkı normal `.map()` operatörü gibi, bir değeri alır (bizim örneğimizde `currentUser` nesnesi) ve onu **başka bir şeye** dönüştürür.
* **Switch (Geçiş) Kısmı:** `switchMap`'in farkı şudur: Dönüştürdüğü "başka şey" **yeni bir Observable (yeni bir akış) olmalıdır.** Bizim örneğimizde bu yeni akış: `this.categoryService.getCategoriesByUserId(currentUser.id)` (yani API'den kategorileri getiren HTTP isteği).

`switchMap` bu iki akışı (dış ve iç) yönetir:

1.  **Dış Akış (Outer Observable):** `this.userService.currentUser` akışınız. Bu akış, kullanıcı giriş/çıkış yaptıkça yeni değerler (`User` nesnesi or `null`) yayınlar. Bu, "uzun ömürlü" bir akıştır; component hayatta olduğu sürece devam eder.
2.  **İç Akış (Inner Observable):** `this.categoryService.getCategoriesByUserId(...)` akışı. Bu, "kısa ömürlü" bir akıştır. Başlar (HTTP isteği gider), bir değer (kategori dizisi) döndürür ve biter (complete).

