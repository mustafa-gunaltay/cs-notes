

# 1) 



## ⚙️ **4️⃣ Operatörler ve Pipe Zinciri**

### 📘 1. Kavramsal Tanım

**Operatörler (Operators)**, bir **Observable**’dan gelen akışı **dönüştürmek, filtrelemek veya birleştirmek** için kullanılır.
RxJS’te yüzlerce operatör vardır ama hepsi aynı felsefeyi paylaşır:

> “Veri akarken üzerinde bir işlem yap.”

Bütün bu operatörler `pipe()` fonksiyonu içinde **zincir** (pipeline) şeklinde bağlanır.

```ts
stream.pipe(
  map(x => x * 2),
  filter(x => x > 5)
)
```

💡 **`pipe()`**, “akış üzerinde bir boru hattı kur” anlamına gelir.
Her operatör bir **yeni stream** döndürür (immutable yapı).
Yani orijinal akış bozulmaz, sadece yeni bir formda akmaya devam eder.

---

### ⚙️ 2. Basit Örnek

```ts
import { from } from 'rxjs';
import { map, filter } from 'rxjs/operators';

const numbers$ = from([1, 2, 3, 4, 5]);

numbers$
  .pipe(
    map(x => x * 10),        // Her değeri 10 ile çarp
    filter(x => x >= 30)     // 30'dan küçükleri çıkar
  )
  .subscribe(result => console.log(result));
```

🧠 **Akışın Mantığı:**

```
1 → 10  ❌
2 → 20  ❌
3 → 30  ✅
4 → 40  ✅
5 → 50  ✅
```

**Çıktı:**

```
30
40
50
```

---

### 🧩 3. Operatör Türleri (Gruplandırılmış)

| Kategori                           | Örnek Operatörler                               | Açıklama                            |
| ---------------------------------- | ----------------------------------------------- | ----------------------------------- |
| **Dönüştürme (Transformation)**    | `map`, `mapTo`, `pluck`                         | Değeri başka bir biçime dönüştürür  |
| **Filtreleme (Filtering)**         | `filter`, `take`, `first`, `debounceTime`       | Akıştaki bazı değerleri atar        |
| **Birleştirme (Combination)**      | `merge`, `combineLatest`, `concat`, `switchMap` | Birden fazla stream’i birleştirir   |
| **Zaman (Time-based)**             | `delay`, `interval`, `throttleTime`             | Zaman bazlı kontrol sağlar          |
| **Hata Yönetimi (Error Handling)** | `catchError`, `retry`                           | Hataları yakalar veya yeniden dener |

---

### ⛓️ 4. `pipe()` Mantığı

`pipe()` fonksiyonu, operatörleri **zincirleme (chaining)** bir şekilde çalıştırır.
Her operatör, bir **Observable** alır ve **yeni bir Observable** döndürür.

```ts
observable.pipe(op1(), op2(), op3());
```

Bu yapı fonksiyonel programlamadaki **“composition (bileşim)”** mantığına çok benzer.
Kodun “nasıl” değil “ne yapılacağını” anlattığı **deklaratif (declarative)** bir tarzdır.

---

### ⚡ 5. Örnek — combineLatest ile Çoklu Akış

```ts
import { combineLatest, of } from 'rxjs';
import { map } from 'rxjs/operators';

const names$ = of('Alice', 'Bob');
const ages$ = of(25, 30);

combineLatest([names$, ages$])
  .pipe(map(([name, age]) => `${name} is ${age} years old`))
  .subscribe(console.log);
```

🧠 **Açıklama:**
`combineLatest`, iki stream’in **son yayılan değerlerini** birleştirir.
Veri, “senkron” değil “reaktif” olarak akışa bağlı şekilde gelir.

---

### ✅ 6. Best Practice

| Prensip                                                          | Açıklama                                                              |
| ---------------------------------------------------------------- | --------------------------------------------------------------------- |
| **1. Side-effect’leri pipe dışına çıkar**                        | Pipe içinde `console.log` veya HTTP çağrısı gibi yan etkiler olmamalı |
| **2. Operatörleri fonksiyonel düşün**                            | Akışı *nasıl* dönüştürdüğünü değil, *neye* dönüştürdüğünü tanımla     |
| **3. Zinciri kısa tut**                                          | Uzun pipe zincirleri kodu okunmaz hale getirir                        |
| **4. combineLatest veya switchMap’i async durumlar için kullan** | Paralel veya dinamik akışları yönetmede güçlüdür                      |

---

### 💡 Soyutlama Cümlesi

> “Reaktif sistemde veri durmaz, akar.
> `pipe()` akışı biçimlendirir, operatörler akışa anlam katar.
> Her dönüşüm yeni bir stream üretir — bu, sistemin fonksiyonel ve yan etkisiz kalmasını sağlar.”

---



# 2) Gercek Hayat Ornegi

```ts
deleteCategory(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`, {
      // 1) Angular’ın HttpClient servisi varsayılan olarak yalnızca response body’yi 
      // döndürür. HTTP status code, headers gibi meta bilgiler gelmez.
      // 2) observe: 'response' kullanarak sadece body’yi değil,
      // tüm HttpResponse objesini alıyoruz
      observe: 'response'
    }).pipe(
      map(response => {
        this.logger.debug('Delete Response', { status: response.status, categoryId: id }, 'CategoryService');
        
        // 204 No Content = Başarılı silme
        if (response.status === 204) {
          this.logger.info('Kategori başarıyla silindi (204 No Content)', { categoryId: id }, 'CategoryService');
          return; // void dönüyoruz
        }
        
        // 200 OK da olabilir (bazı backend'ler 200 döner)
        if (response.status === 200) {
          this.logger.info('Kategori başarıyla silindi (200 OK)', { categoryId: id }, 'CategoryService');
          return;
        }
        
        // Beklenmeyen durum
        this.logger.warn('Beklenmeyen status code', { status: response.status, categoryId: id }, 'CategoryService');
        return;
      }),
      catchError(error => {
        this.logger.error('Kategori silme hatası', { error, categoryId: id, status: error.status }, 'CategoryService');
        
        // 404 Not Found - Kategori bulunamadı
        if (error.status === 404) {
          // Backend BaseResponse dönüyor
          if (error.error && !error.error.isSuccess) {
            const errorMessage = BaseResponseHelper.getAllErrors(error.error);
            this.logger.error('Backend hatası', { errorMessage }, 'CategoryService');
            throw new Error(errorMessage || 'Kategori bulunamadı');
          }
          throw new Error('Kategori bulunamadı');
        }
        
        // 400 Bad Request - Geçersiz ID
        if (error.status === 400) {
          throw new Error('Geçersiz kategori ID\'si');
        }
        
        // 401 Unauthorized - Token geçersiz
        if (error.status === 401) {
          throw new Error('Yetkilendirme hatası. Lütfen tekrar giriş yapın.');
        }
        
        // 403 Forbidden - Erişim izni yok
        if (error.status === 403) {
          throw new Error('Bu kategoriyi silme yetkiniz yok.');
        }
        
        // Diğer hatalar
        return throwError(() => error);
      })
    );
  }
```


## 🧩 HTTP Response & `pipe()` Akışı (Angular + RxJS)

### **1️⃣ `observe: 'response'` Nedir?**

Angular `HttpClient` varsayılan olarak sadece **response body**’yi döndürür.
Ancak aşağıdaki gibi kullanırsan:

```ts
this.http.delete(`${this.apiUrl}/${id}`, { observe: 'response' })
```

artık yalnızca body değil, tüm **HttpResponse** objesini alırsın:

```ts
{
  body: ...,
  status: 204,
  headers: {...},
  url: "https://api.example.com/categories/1"
}
```

> 🎯 `observe: 'response'` → **status**, **headers** ve **body** bilgilerine aynı anda erişebilmeni sağlar.

---

### **2️⃣ `map(response => ...)` ile Bağlantı**

`observe: 'response'` sayesinde artık `pipe(map(...))` içinde `response` bir
**HttpResponse objesi** olur (sadece body değil).

```ts
map(response => {
  if (response.status === 204) {
    this.logger.info('Kategori başarıyla silindi');
    return; // void dönüyor
  }
})
```

> Yani `map()` burada `HttpResponse → void` dönüşümü yapıyor.
> Bu bir “değer dönüşümü”dür, ama `status` kontrolü ve loglama eklenmiştir.

---

### **3️⃣ `map()` ve Dönüştürme Mantığı**

`map()` tipik olarak bir değeri başka bir değere dönüştürmek için kullanılır.
Bu örnekte dönüşüm şu şekilde gerçekleşiyor:

```
HTTP Response (HttpResponse<T>)
     ↓ map()
void (işlenmiş sonuç)
```

Yani `map()` burada **veri dönüştürmek yerine** “işlenmiş duruma” getiriyor
(loglama + `void` dönüş).

---

### **4️⃣ `pipe()`’ın Rolü**

`pipe()` → Bir **reaktif akış boru hattı** kurar.
Her operatör (`map`, `catchError` vb.) akışı işler ve **yeni bir Observable** döndürür:

```ts
this.http.delete(url, { observe: 'response' })
  .pipe(
    map(response => ...),
    catchError(error => ...)
  )
  .subscribe(...)
```

| Operatör       | İşlevi                            |
| -------------- | --------------------------------- |
| `map()`        | Response’u işler / dönüştürür     |
| `catchError()` | Hataları yakalar ve özelleştirir  |
| `subscribe()`  | Component tarafında sonucu dinler |

---

### **5️⃣ `observe` ile `map` Arasındaki İlişki**

| Alan                  | Amacı                                                     | Etki Alanı        |
| --------------------- | --------------------------------------------------------- | ----------------- |
| `observe: 'response'` | Angular’ın `HttpClient`’ine tam yanıt döndürmesini söyler | HTTP Katmanı      |
| `map(response => …)`  | Bu yanıtı uygulama seviyesinde işler                      | RxJS Akış Katmanı |

---

