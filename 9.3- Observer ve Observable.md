

# 1)



## ğŸ§© **3ï¸âƒ£ GÃ¶zlemci (Observer) ve GÃ¶zlemlenen (Observable)**

### ğŸ“˜ 1. Kavramsal TanÄ±m

Reaktif sistemin iki ana aktÃ¶rÃ¼ vardÄ±r:

* **Observable (GÃ¶zlemlenen):**
  Veriyi **Ã¼reten ve emit eden** (yayÄ±nlayan) taraftÄ±r.
  Zaman iÃ§inde bir veya birden fazla deÄŸer Ã¼retir.

* **Observer (GÃ¶zlemci):**
  Bu akÄ±ÅŸÄ± **subscribe()** vasitasiyla dinleyen taraftÄ±r.
  Observable her deÄŸer yayÄ±nladÄ±ÄŸÄ±nda Observer bir tepki verir.


---

### âš™ï¸ 2. Basit Ã–rnek

```ts
import { Observable } from 'rxjs';

// Observable: veri kaynaÄŸÄ±nÄ± tanÄ±mlÄ±yoruz
const observable = new Observable(subscriber => {
  subscriber.next('Merhaba');
  subscriber.next('Reaktif DÃ¼nya');
  subscriber.complete();
});

// Observer: nasÄ±l tepki verileceÄŸini tanÄ±mlÄ±yoruz
const observer = {
  next: (value: string) => console.log('Yeni veri:', value),
  complete: () => console.log('AkÄ±ÅŸ tamamlandÄ±')
};

// AkÄ±ÅŸÄ± baÅŸlat (abonelik)
observable.subscribe(observer);
```

ğŸ§  **Ne oldu burada?**

1. `Observable` â†’ veriyi â€œemitâ€ etti (`next()` Ã§aÄŸrÄ±sÄ±).
2. `Observer` â†’ bu yayÄ±nÄ± dinledi ve tepki verdi (`console.log` ile).
3. `complete()` Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda akÄ±ÅŸ sona erdi.

---

### ğŸ”„ 3. `subscribe()` ve `unsubscribe()`

`Ornek:`

`x.subscribe(y)`

* `subscribe()` â†’ x (gozlemlenen) ile y (gozlemci) arasindaki â€œbaÄŸlantÄ±yÄ± kurarâ€. Yani y, x'den gelen stream'i dinlemeye baÅŸlar ve stream degistinde buna y icinde tanimlanan metotlara gore tepki verir.
* `unsubscribe()` â†’  x (gozlemlenen) ile y (gozlemci) arasindaki â€œbaÄŸlantÄ±yÄ± koparÄ±râ€. Yani y, x'den gelen stream'i dinlemeyi birakir, x'de bir degisiklik oldugunda tepki (react) verilmez.

Bu mekanizma, **memory leak (bellek sÄ±zÄ±ntÄ±sÄ±)** riskini Ã¶nlemek iÃ§in Ã§ok Ã¶nemlidir.

```ts
const subscription = observable.subscribe(value => console.log(value));
subscription.unsubscribe(); // artÄ±k dinlemiyor
```

ğŸ’¡ **Best practice:**
Angular bileÅŸenlerinde (component) genellikle `ngOnDestroy()` iÃ§inde `unsubscribe()` yapÄ±lÄ±r.

---


### ğŸ§± 5. Best Practice Ã–zeti

| Prensip                                        | AÃ§Ä±klama                                                               |
| ---------------------------------------------- | ---------------------------------------------------------------------- |
| **1. Abonelikleri yÃ¶net**                      | `subscribe()` sonrasÄ± `unsubscribe()` yapmazsan bellek sÄ±zÄ±ntÄ±sÄ± olur. |
| **2. Tek sorumluluk**                          | Observable yalnÄ±zca veri Ã¼retmeli, Observer yalnÄ±zca tepki vermeli.    |
| **3. AkÄ±ÅŸ kontrolÃ¼ operatÃ¶rlerle yapÄ±lmalÄ±**   | Ã–rneÄŸin `pipe()`, `map()`, `filter()` gibi.                            |
| **4. Hata ve tamamlama yÃ¶netimini ihmal etme** | `error` ve `complete` eventâ€™lerini daima tanÄ±mla.                      |

---

### ğŸ’¡ Soyutlama CÃ¼mlesi

> â€œObservable veriyi emit eder, Observer bu verilere tepki verir.
> `subscribe()` veri akÄ±ÅŸÄ±nÄ± baÅŸlatÄ±r, `unsubscribe()` ise gÃ¼venli ÅŸekilde sonlandÄ±rÄ±r.â€

---














# 2) Hot vs Cold Observables

### ğŸ“˜ 1. Kavramsal TanÄ±m

Reaktif sistemlerde her **Observable**, veriyi nasÄ±l paylaÅŸtÄ±ÄŸÄ±na gÃ¶re iki kategoriye ayrÄ±lÄ±r:

* **Cold Observable (SoÄŸuk AkÄ±ÅŸ):**

  * Her `subscribe()` Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda **akÄ±ÅŸÄ± baÅŸtan baÅŸlatÄ±r**.
  * Yani her abone kendi kopyasÄ±nÄ± alÄ±r.
  * Ã–rneÄŸin: `http.get()` veya `of()` gibi kaynaklar â€” her dinleyici iÃ§in veri yeniden Ã¼retilir.

* **Hot Observable (SÄ±cak AkÄ±ÅŸ):**

  * Veriyi **ortak bir kaynaktan** Ã¼retir.
  * Yeni gelen aboneler, akÄ±ÅŸÄ±n ortasÄ±ndan dahil olur (Ã¶nceki verileri almaz).
  * Ã–rneÄŸin: WebSocket, kullanÄ±cÄ± tÄ±klamalarÄ±, canlÄ± sensÃ¶r verileri.

ğŸ’¡ **Soyut TanÄ±m:**

> Cold Observable â†’ Her abone kendi yayÄ±nÄ± alÄ±r.
> Hot Observable â†’ TÃ¼m aboneler aynÄ± yayÄ±nÄ± paylaÅŸÄ±r.

---

### âš™ï¸ 2. Cold Observable Ã–rneÄŸi

```ts
import { of } from 'rxjs';

const cold$ = of(Math.random());

cold$.subscribe(val => console.log('Abone 1:', val));
cold$.subscribe(val => console.log('Abone 2:', val));
```

ğŸ“¤ **Ã‡Ä±ktÄ±:**

```
Abone 1: 0.2354
Abone 2: 0.7219
```

ğŸ§  **AÃ§Ä±klama:**

* `Math.random()` her `subscribe()` Ã§aÄŸrÄ±sÄ±nda yeniden Ã§alÄ±ÅŸÄ±r.
* Yani her abone **farklÄ± bir veri** alÄ±r.
* Bu yÃ¼zden â€œColdâ€ (soÄŸuk) â†’ AkÄ±ÅŸ yalnÄ±zca abone olduÄŸunda baÅŸlar.

---

### âš¡ 3. Hot Observable Ã–rneÄŸi

```ts
import { interval, share } from 'rxjs';

const hot$ = interval(1000).pipe(share());

hot$.subscribe(val => console.log('Abone 1:', val));

setTimeout(() => {
  hot$.subscribe(val => console.log('Abone 2:', val));
}, 3000);
```

ğŸ“¤ **Ã‡Ä±ktÄ±:**

```
Abone 1: 0
Abone 1: 1
Abone 1: 2
Abone 2: 2
Abone 1: 3
Abone 2: 3
```

ğŸ§  **AÃ§Ä±klama:**

* `share()` operatÃ¶rÃ¼ akÄ±ÅŸÄ± â€œhotâ€ hale getirir â†’ aboneler aynÄ± kaynaktan veri alÄ±r.
* `Abone 2` geÃ§ katÄ±ldÄ±ÄŸÄ± iÃ§in sadece **katÄ±ldÄ±ÄŸÄ± andan itibaren** olan deÄŸerleri gÃ¶rÃ¼r.
* AkÄ±ÅŸ zaten Ã§alÄ±ÅŸÄ±yordur; yeni biri geldiÄŸinde â€œdevam eden yayÄ±naâ€ dahil olur.

---

### ğŸ”„ 4. KarÅŸÄ±laÅŸtÄ±rma Tablosu

| Ã–zellik               | **Cold Observable**          | **Hot Observable**                      |
| --------------------- | ---------------------------- | --------------------------------------- |
| Veri Ã¼retimi          | Her `subscribe()` ile baÅŸlar | Kaynak baÅŸlatÄ±ldÄ±ÄŸÄ±nda baÅŸlar           |
| Abone davranÄ±ÅŸÄ±       | Herkes kendi verisini alÄ±r   | Herkes aynÄ± veriyi paylaÅŸÄ±r             |
| KullanÄ±m Ã¶rnekleri    | HTTP istekleri, dosya okuma  | WebSocket, kullanÄ±cÄ± eventleri          |
| Geciken abone         | BaÅŸtan baÅŸlar                | Ortadan katÄ±lÄ±r                         |
| PaylaÅŸÄ±m operatÃ¶rleri | â€”                            | `share()`, `shareReplay()`, `publish()` |

---

### ğŸ’» 5. GerÃ§ek Hayat Senaryosu

**Cold Ã¶rneÄŸi â€“ HTTP isteÄŸi:**

```ts
this.http.get('/api/users').subscribe();
this.http.get('/api/users').subscribe();
```

â¡ï¸ Her biri yeni bir HTTP isteÄŸi gÃ¶nderir (iki ayrÄ± network Ã§aÄŸrÄ±sÄ±).

**Hot Ã¶rneÄŸi â€“ PaylaÅŸÄ±lan veri akÄ±ÅŸÄ±:**

```ts
const users$ = this.http.get('/api/users').pipe(shareReplay(1));

users$.subscribe();
users$.subscribe();
```

â¡ï¸ `shareReplay(1)` sayesinde **tek bir HTTP isteÄŸi** yapÄ±lÄ±r,
ve iki abonede de aynÄ± sonuÃ§ paylaÅŸÄ±lÄ±r.

---

### âœ… 6. Best Practice

| Prensip                                         | AÃ§Ä±klama                                                                   |
| ----------------------------------------------- | -------------------------------------------------------------------------- |
| **1. HTTP isteklerinde Cold kullan**            | Her `subscribe()`â€™Ä±n kendi isteÄŸini atmasÄ± genellikle istenen davranÄ±ÅŸtÄ±r. |
| **2. PaylaÅŸÄ±lan stateâ€™lerde Hot kullan**        | WebSocket, global kullanÄ±cÄ± state, veya cache veriler Hot olmalÄ±dÄ±r.       |
| **3. `share()` veya `shareReplay()` ile yÃ¶net** | `share()` tek akÄ±ÅŸÄ± paylaÅŸÄ±r, `shareReplay()` geÃ§miÅŸ veriyi de saklar.     |
| **4. Stream tipini bilinÃ§li seÃ§**               | Her akÄ±ÅŸÄ±n â€œsoÄŸuk mu sÄ±cak mÄ±â€ olduÄŸunu bilmek, bugâ€™larÄ±n Ã§oÄŸunu Ã¶nler.    |

---

### ğŸ’¡ Soyutlama CÃ¼mlesi

> Reaktif sistemde her akÄ±ÅŸÄ±n bir â€œÄ±sÄ± derecesiâ€ vardÄ±r:
> *Cold Observables* kendi akÄ±ÅŸÄ±nÄ± Ã¼retir,
> *Hot Observables* tek bir akÄ±ÅŸÄ± paylaÅŸÄ±r.
> BÃ¶ylece performans, tutarlÄ±lÄ±k ve kaynak yÃ¶netimi akÄ±ÅŸ tÃ¼rÃ¼ne gÃ¶re kontrol edilir.

---
