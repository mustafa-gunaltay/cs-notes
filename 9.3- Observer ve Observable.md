

# 1)



## 🧩 **3️⃣ Gözlemci (Observer) ve Gözlemlenen (Observable)**

### 📘 1. Kavramsal Tanım

Reaktif sistemin iki ana aktörü vardır:

* **Observable (Gözlemlenen):**
  Veriyi **üreten ve emit eden** (yayınlayan) taraftır.
  Zaman içinde bir veya birden fazla değer üretir.

* **Observer (Gözlemci):**
  Bu akışı **subscribe()** vasitasiyla dinleyen taraftır.
  Observable her değer yayınladığında Observer bir tepki verir.


---

### ⚙️ 2. Basit Örnek

```ts
import { Observable } from 'rxjs';

// Observable: veri kaynağını tanımlıyoruz
const observable = new Observable(subscriber => {
  subscriber.next('Merhaba');
  subscriber.next('Reaktif Dünya');
  subscriber.complete();
});

// Observer: nasıl tepki verileceğini tanımlıyoruz
const observer = {
  next: (value: string) => console.log('Yeni veri:', value),
  complete: () => console.log('Akış tamamlandı')
};

// Akışı başlat (abonelik)
observable.subscribe(observer);
```

🧠 **Ne oldu burada?**

1. `Observable` → veriyi “emit” etti (`next()` çağrısı).
2. `Observer` → bu yayını dinledi ve tepki verdi (`console.log` ile).
3. `complete()` çağrıldığında akış sona erdi.

---

### 🔄 3. `subscribe()` ve `unsubscribe()`

`Ornek:`

`x.subscribe(y)`

* `subscribe()` → x (gozlemlenen) ile y (gozlemci) arasindaki “bağlantıyı kurar”. Yani y, x'den gelen stream'i dinlemeye başlar ve stream degistinde buna y icinde tanimlanan metotlara gore tepki verir.
* `unsubscribe()` →  x (gozlemlenen) ile y (gozlemci) arasindaki “bağlantıyı koparır”. Yani y, x'den gelen stream'i dinlemeyi birakir, x'de bir degisiklik oldugunda tepki (react) verilmez.

Bu mekanizma, **memory leak (bellek sızıntısı)** riskini önlemek için çok önemlidir.

```ts
const subscription = observable.subscribe(value => console.log(value));
subscription.unsubscribe(); // artık dinlemiyor
```

💡 **Best practice:**
Angular bileşenlerinde (component) genellikle `ngOnDestroy()` içinde `unsubscribe()` yapılır.

---


### 🧱 5. Best Practice Özeti

| Prensip                                        | Açıklama                                                               |
| ---------------------------------------------- | ---------------------------------------------------------------------- |
| **1. Abonelikleri yönet**                      | `subscribe()` sonrası `unsubscribe()` yapmazsan bellek sızıntısı olur. |
| **2. Tek sorumluluk**                          | Observable yalnızca veri üretmeli, Observer yalnızca tepki vermeli.    |
| **3. Akış kontrolü operatörlerle yapılmalı**   | Örneğin `pipe()`, `map()`, `filter()` gibi.                            |
| **4. Hata ve tamamlama yönetimini ihmal etme** | `error` ve `complete` event’lerini daima tanımla.                      |

---

### 💡 Soyutlama Cümlesi

> “Observable veriyi emit eder, Observer bu verilere tepki verir.
> `subscribe()` veri akışını başlatır, `unsubscribe()` ise güvenli şekilde sonlandırır.”

---














# 2) Hot vs Cold Observables

### 📘 1. Kavramsal Tanım

Reaktif sistemlerde her **Observable**, veriyi nasıl paylaştığına göre iki kategoriye ayrılır:

* **Cold Observable (Soğuk Akış):**

  * Her `subscribe()` çağrıldığında **akışı baştan başlatır**.
  * Yani her abone kendi kopyasını alır.
  * Örneğin: `http.get()` veya `of()` gibi kaynaklar — her dinleyici için veri yeniden üretilir.

* **Hot Observable (Sıcak Akış):**

  * Veriyi **ortak bir kaynaktan** üretir.
  * Yeni gelen aboneler, akışın ortasından dahil olur (önceki verileri almaz).
  * Örneğin: WebSocket, kullanıcı tıklamaları, canlı sensör verileri.

💡 **Soyut Tanım:**

> Cold Observable → Her abone kendi yayını alır.
> Hot Observable → Tüm aboneler aynı yayını paylaşır.

---

### ⚙️ 2. Cold Observable Örneği

```ts
import { of } from 'rxjs';

const cold$ = of(Math.random());

cold$.subscribe(val => console.log('Abone 1:', val));
cold$.subscribe(val => console.log('Abone 2:', val));
```

📤 **Çıktı:**

```
Abone 1: 0.2354
Abone 2: 0.7219
```

🧠 **Açıklama:**

* `Math.random()` her `subscribe()` çağrısında yeniden çalışır.
* Yani her abone **farklı bir veri** alır.
* Bu yüzden “Cold” (soğuk) → Akış yalnızca abone olduğunda başlar.

---

### ⚡ 3. Hot Observable Örneği

```ts
import { interval, share } from 'rxjs';

const hot$ = interval(1000).pipe(share());

hot$.subscribe(val => console.log('Abone 1:', val));

setTimeout(() => {
  hot$.subscribe(val => console.log('Abone 2:', val));
}, 3000);
```

📤 **Çıktı:**

```
Abone 1: 0
Abone 1: 1
Abone 1: 2
Abone 2: 2
Abone 1: 3
Abone 2: 3
```

🧠 **Açıklama:**

* `share()` operatörü akışı “hot” hale getirir → aboneler aynı kaynaktan veri alır.
* `Abone 2` geç katıldığı için sadece **katıldığı andan itibaren** olan değerleri görür.
* Akış zaten çalışıyordur; yeni biri geldiğinde “devam eden yayına” dahil olur.

---

### 🔄 4. Karşılaştırma Tablosu

| Özellik               | **Cold Observable**          | **Hot Observable**                      |
| --------------------- | ---------------------------- | --------------------------------------- |
| Veri üretimi          | Her `subscribe()` ile başlar | Kaynak başlatıldığında başlar           |
| Abone davranışı       | Herkes kendi verisini alır   | Herkes aynı veriyi paylaşır             |
| Kullanım örnekleri    | HTTP istekleri, dosya okuma  | WebSocket, kullanıcı eventleri          |
| Geciken abone         | Baştan başlar                | Ortadan katılır                         |
| Paylaşım operatörleri | —                            | `share()`, `shareReplay()`, `publish()` |

---

### 💻 5. Gerçek Hayat Senaryosu

**Cold örneği – HTTP isteği:**

```ts
this.http.get('/api/users').subscribe();
this.http.get('/api/users').subscribe();
```

➡️ Her biri yeni bir HTTP isteği gönderir (iki ayrı network çağrısı).

**Hot örneği – Paylaşılan veri akışı:**

```ts
const users$ = this.http.get('/api/users').pipe(shareReplay(1));

users$.subscribe();
users$.subscribe();
```

➡️ `shareReplay(1)` sayesinde **tek bir HTTP isteği** yapılır,
ve iki abonede de aynı sonuç paylaşılır.

---

### ✅ 6. Best Practice

| Prensip                                         | Açıklama                                                                   |
| ----------------------------------------------- | -------------------------------------------------------------------------- |
| **1. HTTP isteklerinde Cold kullan**            | Her `subscribe()`’ın kendi isteğini atması genellikle istenen davranıştır. |
| **2. Paylaşılan state’lerde Hot kullan**        | WebSocket, global kullanıcı state, veya cache veriler Hot olmalıdır.       |
| **3. `share()` veya `shareReplay()` ile yönet** | `share()` tek akışı paylaşır, `shareReplay()` geçmiş veriyi de saklar.     |
| **4. Stream tipini bilinçli seç**               | Her akışın “soğuk mu sıcak mı” olduğunu bilmek, bug’ların çoğunu önler.    |

---

### 💡 Soyutlama Cümlesi

> Reaktif sistemde her akışın bir “ısı derecesi” vardır:
> *Cold Observables* kendi akışını üretir,
> *Hot Observables* tek bir akışı paylaşır.
> Böylece performans, tutarlılık ve kaynak yönetimi akış türüne göre kontrol edilir.

---
