
# 1)


## âš™ï¸ **2ï¸âƒ£ Sequential Execution vs Reactive Flow**

### ðŸ“˜ 1. Klasik (Sequential) YaklaÅŸÄ±m

Klasik (imperatif) programlama dÃ¼nyasÄ±nda kodlar **sÄ±ra ile** Ã§alÄ±ÅŸÄ±r:
Bir satÄ±r bitmeden diÄŸeri baÅŸlamaz.
Veri akÄ±ÅŸÄ± *kontrol akÄ±ÅŸÄ±yla* aynÄ±dÄ±r.

```js
// Sequential (sÄ±ralÄ±) Ã¶rnek
console.log('1');
console.log('2');
console.log('3');

// Output:
1
2
3
```

ðŸ’¡ Burada zaman boyutu **yoktur** â€” her ÅŸey ardÄ±ÅŸÄ±k ÅŸekilde gerÃ§ekleÅŸir.
ProgramÄ±n kontrolÃ¼ tamamen geliÅŸtiricidedir.

---

### âš¡ 2. Reaktif (Event-Driven) YaklaÅŸÄ±m

Reaktif programlamada kontrol akÄ±ÅŸÄ±, **verinin geliÅŸ zamanÄ±na** gÃ¶re ÅŸekillenir.
Yani program â€œsÄ±rayla iÅŸlemezâ€, **olaylar gerÃ§ekleÅŸtikÃ§e tepki verir.**

```ts
import { interval } from 'rxjs';

const stream$ = interval(1000); // her saniye bir deÄŸer Ã¼retir (emit)

stream$.subscribe(value => console.log('Yeni deÄŸer:', value));
```

â±ï¸ **Ã‡Ä±ktÄ± (zaman iÃ§inde):**

```
Yeni deÄŸer: 0
Yeni deÄŸer: 1
Yeni deÄŸer: 2
...
```

Burada:

* `interval(1000)` â†’ her saniye yeni bir olay (deÄŸer) *emit* eder,
* `subscribe()` â†’ bu olaylara tepki verir.

Yani artÄ±k **zaman** programÄ±n doÄŸasÄ±nda vardÄ±r,
ve **akÄ±ÅŸÄ±n hÄ±zÄ± veya sÄ±rasÄ± veri kaynaÄŸÄ± tarafÄ±ndan belirlenir.**

---

### ðŸ”„ 3. Zihinsel DÃ¶nÃ¼ÅŸÃ¼m

| Geleneksel (Sequential)        | Reaktif (Flow-based)                |
| ------------------------------ | ----------------------------------- |
| Kod akÄ±ÅŸÄ± sabittir             | Kod, olaylara tepki verir           |
| DeÄŸerler anlÄ±k Ã¼retilir        | DeÄŸerler zamanla akar               |
| `for`, `if`, `while` odaklÄ±dÄ±r | `pipe()`, `subscribe()` odaklÄ±dÄ±r   |
| Program veriyle ilgilenir      | Program veri **akÄ±ÅŸÄ±yla** ilgilenir |

---

### ðŸ§  4. Soyutlama Fikri

> â€œSequential executionâ€ = *â€˜Ne zaman Ã§alÄ±ÅŸacaÄŸÄ±nÄ± ben belirlerim.â€™*
> â€œReactive flowâ€ = *â€˜Veri geldiÄŸinde ben tepki veririm.â€™*

Zaman artÄ±k bir deÄŸiÅŸken deÄŸil, **akÄ±ÅŸÄ±n parÃ§asÄ±dÄ±r**.
Bu, reaktif dÃ¼ÅŸÃ¼ncenin Ã¶zÃ¼dÃ¼r.

---

### âœ… Best Practice

| Prensip                                     | AÃ§Ä±klama                                            |
| ------------------------------------------- | --------------------------------------------------- |
| **Kod akÄ±ÅŸÄ±nÄ± deÄŸil, veri akÄ±ÅŸÄ±nÄ± tasarla** | Eventâ€™leri modelle, sÄ±rayÄ± deÄŸil                    |
| **ZamanÄ± bilinÃ§li yÃ¶net**                   | `interval`, `timer`, `debounceTime` operatÃ¶rleriyle |
| **Side-effectâ€™leri minimize et**            | Tepkileri saf fonksiyonlarla iÅŸle                   |
| **â€œNe zamanâ€ yerine â€œne olduÄŸundaâ€ dÃ¼ÅŸÃ¼n**  | Ã–rneÄŸin â€œkullanÄ±cÄ± tÄ±klarsaâ€, â€œveri gelirseâ€        |

---

ðŸ’¡ **KÄ±sa Soyutlama CÃ¼mlesi**

> â€œReaktif akÄ±ÅŸta, kod olaylarÄ±n sÄ±rasÄ±na gÃ¶re Ã§alÄ±ÅŸÄ±r;
> artÄ±k kontrol akÄ±ÅŸÄ± deÄŸil, veri akÄ±ÅŸÄ± sistemin yÃ¶nÃ¼nÃ¼ belirler.â€

---



# Eklemeler

## 1) Reactive Flow icinde Sequential Execution (RxJS icinde Sequential Execution)

- Bazen bir component icinde subscription islemi yapilacagi zaman, servisler birbirine bagli olabilir, yani bir servisin ciktisindan elde edilecek bir cikti baska bir servis icinde kullanilacak olabilir.


- Ornek: 
    - Step1, Step2, Step3 seklinde 3 tane stream donduren (mesela Observable) servisimiz olsun
    - Step1 bagimsiz calissin ve step3, step2'den gelecek bir veriye bagimli olsun

```ts
import { forkJoin } from 'rxjs';
import { concatMap } from 'rxjs/operators';

const step1$  = this.api.step1(); // baÄŸÄ±msÄ±z iÅŸ
const step23$ = this.api.step2().pipe(
  concatMap(res2 => this.api.step3(res2)) // step3, step2'den beslenir
);

forkJoin({
  step1: step1$,
  step23: step23$
}).subscribe(({ step1, step23 }) => {
  console.log('step1 sonucu:', step1);
  console.log('step2â†’step3 sonucu:', step23);
});

```
