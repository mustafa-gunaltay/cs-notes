
# 1)


## ⚙️ **2️⃣ Sequential Execution vs Reactive Flow**

### 📘 1. Klasik (Sequential) Yaklaşım

Klasik (imperatif) programlama dünyasında kodlar **sıra ile** çalışır:
Bir satır bitmeden diğeri başlamaz.
Veri akışı *kontrol akışıyla* aynıdır.

```js
// Sequential (sıralı) örnek
console.log('1');
console.log('2');
console.log('3');

// Output:
1
2
3
```

💡 Burada zaman boyutu **yoktur** — her şey ardışık şekilde gerçekleşir.
Programın kontrolü tamamen geliştiricidedir.

---

### ⚡ 2. Reaktif (Event-Driven) Yaklaşım

Reaktif programlamada kontrol akışı, **verinin geliş zamanına** göre şekillenir.
Yani program “sırayla işlemez”, **olaylar gerçekleştikçe tepki verir.**

```ts
import { interval } from 'rxjs';

const stream$ = interval(1000); // her saniye bir değer üretir (emit)

stream$.subscribe(value => console.log('Yeni değer:', value));
```

⏱️ **Çıktı (zaman içinde):**

```
Yeni değer: 0
Yeni değer: 1
Yeni değer: 2
...
```

Burada:

* `interval(1000)` → her saniye yeni bir olay (değer) *emit* eder,
* `subscribe()` → bu olaylara tepki verir.

Yani artık **zaman** programın doğasında vardır,
ve **akışın hızı veya sırası veri kaynağı tarafından belirlenir.**

---

### 🔄 3. Zihinsel Dönüşüm

| Geleneksel (Sequential)        | Reaktif (Flow-based)                |
| ------------------------------ | ----------------------------------- |
| Kod akışı sabittir             | Kod, olaylara tepki verir           |
| Değerler anlık üretilir        | Değerler zamanla akar               |
| `for`, `if`, `while` odaklıdır | `pipe()`, `subscribe()` odaklıdır   |
| Program veriyle ilgilenir      | Program veri **akışıyla** ilgilenir |

---

### 🧠 4. Soyutlama Fikri

> “Sequential execution” = *‘Ne zaman çalışacağını ben belirlerim.’*
> “Reactive flow” = *‘Veri geldiğinde ben tepki veririm.’*

Zaman artık bir değişken değil, **akışın parçasıdır**.
Bu, reaktif düşüncenin özüdür.

---

### ✅ Best Practice

| Prensip                                     | Açıklama                                            |
| ------------------------------------------- | --------------------------------------------------- |
| **Kod akışını değil, veri akışını tasarla** | Event’leri modelle, sırayı değil                    |
| **Zamanı bilinçli yönet**                   | `interval`, `timer`, `debounceTime` operatörleriyle |
| **Side-effect’leri minimize et**            | Tepkileri saf fonksiyonlarla işle                   |
| **“Ne zaman” yerine “ne olduğunda” düşün**  | Örneğin “kullanıcı tıklarsa”, “veri gelirse”        |

---

💡 **Kısa Soyutlama Cümlesi**

> “Reaktif akışta, kod olayların sırasına göre çalışır;
> artık kontrol akışı değil, veri akışı sistemin yönünü belirler.”

---



# Eklemeler

## 1) Reactive Flow icinde Sequential Execution (RxJS icinde Sequential Execution)

- Bazen bir component icinde subscription islemi yapilacagi zaman, servisler birbirine bagli olabilir, yani bir servisin ciktisindan elde edilecek bir cikti baska bir servis icinde kullanilacak olabilir.


- Ornek: 
    - Step1, Step2, Step3 seklinde 3 tane stream donduren (mesela Observable) servisimiz olsun
    - Step1 bagimsiz calissin ve step3, step2'den gelecek bir veriye bagimli olsun

```ts
import { forkJoin } from 'rxjs';
import { concatMap } from 'rxjs/operators';

const step1$  = this.api.step1(); // bağımsız iş
const step23$ = this.api.step2().pipe(
  concatMap(res2 => this.api.step3(res2)) // step3, step2'den beslenir
);

forkJoin({
  step1: step1$,
  step23: step23$
}).subscribe(({ step1, step23 }) => {
  console.log('step1 sonucu:', step1);
  console.log('step2→step3 sonucu:', step23);
});

```
