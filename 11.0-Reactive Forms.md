

# 1) Reactive Forms nedir?

- `Reactive Forms` bir **konsepttir**. 
- FormGroup, FormControl, FormArray, Validators gibi yapilar bu konsepti Angular'da implement eden yapilardir.











# 2) Reaktiflik tam olarak nerede?


### A. AnÄ±nda Senkronizasyon (Model â€¹-â€º View)

Bu, reaktifliÄŸin en bariz, ilk seviyesidir.

`FormGroup`'unuzu (`.ts` dosyasÄ±) HTML (`.html` dosyasÄ±) ile `[formGroup]` ve `formControlName` direktiflerini kullanarak baÄŸladÄ±ÄŸÄ±nÄ±z anda, "iki yÃ¶nlÃ¼ reaktif bir kÃ¶prÃ¼" kurarsÄ±nÄ±z:

1.  **View -\> Model Tepkisi:** KullanÄ±cÄ± `<input>` alanÄ±na tek bir harf (`V`) yazdÄ±ÄŸÄ± anda (`View` deÄŸiÅŸir), TypeScript kodunuzdaki `FormControl`'Ã¼n deÄŸeri *anÄ±nda* (`V` olarak) gÃ¼ncellenir. Model, View'daki deÄŸiÅŸikliÄŸe *tepki verir*.
2.  **Model -\> View Tepkisi:** Siz TypeScript kodunuzda `this.form.patchValue({ ... })` Ã§aÄŸrÄ±sÄ± yaptÄ±ÄŸÄ±nÄ±z anda (`Model` deÄŸiÅŸir), HTML'deki ilgili `<input>` alanlarÄ±nÄ±n deÄŸeri *anÄ±nda* gÃ¼ncellenir. View, Model'deki deÄŸiÅŸikliÄŸe *tepki verir*.

Bu, Template-Driven (`ngModel`) formlarda da vardÄ±r, ancak Reactive Forms'da bu baÄŸ *aÃ§Ä±kÃ§a* (explicit) sizin tarafÄ±nÄ±zdan kurulur.

### B. DeÄŸer AkÄ±ÅŸlarÄ± (RxJS Observables) - (Ä°smin AsÄ±l Nedeni)

"Reaktif" isminin **asÄ±l ve en gÃ¼Ã§lÃ¼** nedeni budur. Reactive Forms, Angular'Ä±n temelini oluÅŸturan **RxJS (Reactive Extensions for JavaScript)** kÃ¼tÃ¼phanesi ile tamamen entegredir.

Reactive Forms'da oluÅŸturduÄŸunuz *her bir kontrol* (`FormControl`, `FormGroup`, `FormArray`), durumunu ve deÄŸerini **Observable (GÃ¶zlemlenebilir AkÄ±ÅŸ)** olarak dÄ±ÅŸarÄ±ya yayÄ±nlar.

Ä°ki ana akÄ±ÅŸ vardÄ±r:

1.  **`valueChanges` (DeÄŸer DeÄŸiÅŸiklikleri):**

      * Bu, bir `FormControl`'Ã¼n deÄŸerini bir "veri akÄ±ÅŸÄ±" olarak sunan bir `Observable`'dÄ±r.
      * Form alanÄ±na yazÄ±lan *her bir harfte* bu akÄ±ÅŸ yeni bir deÄŸer yayÄ±nlar.
      * Siz bu akÄ±ÅŸa `subscribe` olarak bu deÄŸiÅŸikliklere *anÄ±nda tepki* verebilirsiniz.

2.  **`statusChanges` (Durum DeÄŸiÅŸiklikleri):**

      * Bu, kontrolÃ¼n geÃ§erlilik durumunu (`'VALID'`, `'INVALID'`, `'PENDING'`) bir akÄ±ÅŸ olarak sunar.
      * Siz bu akÄ±ÅŸa `subscribe` olarak, Ã¶rneÄŸin form geÃ§ersiz (invalid) olduÄŸu anda "Kaydet" butonunu *reaktif olarak* devre dÄ±ÅŸÄ± bÄ±rakabilirsiniz.

#### 1\. ğŸ¯ **`valueChanges` Ã–rneÄŸi**

**Senaryo:** Projenizin kurallarÄ±nda "EÄŸer 'Ã–ncelik' (Priority) 'YÃ¼ksek' olarak seÃ§ilirse, 'Son Teslim Tarihi' (DueDate) zorunlu olsun" kuralÄ± var.

Bunu, `priority` alanÄ±nÄ±n `valueChanges` akÄ±ÅŸÄ±nÄ± dinleyerek reaktif olarak yÃ¶netebiliriz.

```typescript
// task-create.component.ts bazinda ornek

// 1. Ä°lgili FormControl'leri alÄ±n
const priorityControl = this.taskForm.controls.priority;
const dueDateControl = this.taskForm.controls.dueDate;

// 2. 'priority' alanÄ±nÄ±n DEÄER AKIÅINA (valueChanges) abone olun
priorityControl.valueChanges
  .pipe(
    // Component destroy olduÄŸunda bu aboneliÄŸi otomatik bitir
    takeUntilDestroyed(this.destroyRef) 
  )
  .subscribe(newPriority => {
    
    // 3. REAKSÄ°YON: Yeni seÃ§ilen Ã¶ncelik 'YÃ¼ksek' mi?
    if (newPriority === Priority.High) {
      
      // 'YÃ¼ksek' ise: dueDate alanÄ±na 'zorunlu' kuralÄ±nÄ± ekle
      this.logger.debug('Priority High, DueDate is now required.');
      dueDateControl.setValidators([Validators.required]);

    } else {

      // 'YÃ¼ksek' deÄŸilse: dueDate alanÄ±ndaki tÃ¼m kurallarÄ± (validator) temizle
      this.logger.debug('Priority not High, DueDate is now optional.');
      dueDateControl.clearValidators();
    }
    
    // 4. DeÄŸiÅŸikliÄŸin geÃ§erli olmasÄ± iÃ§in kontrolÃ¼ gÃ¼ncelle
    dueDateControl.updateValueAndValidity(); 
  });
```

**Bu neden reaktiftir?**
Siz "EÄŸer Ã¶ncelik yÃ¼ksekse, son tarih zorunludur" kuralÄ±nÄ± *bir kez* tanÄ±mladÄ±nÄ±z. ArtÄ±k `priority` dropdown'Ä± her deÄŸiÅŸtiÄŸinde, `dueDate` alanÄ± bu deÄŸiÅŸikliÄŸe *otomatik olarak tepki verir* (reacts) ve kendi kurallarÄ±nÄ± (validasyonunu) gÃ¼nceller.





#### 2\. ğŸ¯ **`statusChanges` Ã–rneÄŸi**

**Senaryo:** Formun *tamamÄ±nÄ±n* geÃ§erlilik durumu (`VALID` veya `INVALID`) her deÄŸiÅŸtiÄŸinde bunu konsola yazdÄ±rmak ve `submitState` butonunun durumunu programatik olarak yÃ¶netmek istiyorsunuz.

(Not: HTML'de `[disabled]="taskForm.invalid"` kullanmak daha yaygÄ±ndÄ±r, bu sadece `statusChanges`'in *nasÄ±l* Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± gÃ¶steren programatik bir Ã¶rnektir.)

```typescript
// task-create.component.ts bazinda ornek

// 1. Formun tamamÄ±nÄ±n DURUM AKIÅINA (statusChanges) abone olun
this.taskForm.statusChanges
  .pipe(
    takeUntilDestroyed(this.destroyRef)
  )
  .subscribe(newStatus => {
    
    // newStatus, 'VALID', 'INVALID', veya 'PENDING' olabilir
    this.logger.debug(`Form status changed to: ${newStatus}`);
    
    // 3. REAKSÄ°YON: Form geÃ§ersiz (INVALID) mi?
    if (newStatus === 'INVALID') {
      
      // Ã–rneÄŸin, form geÃ§ersizse ve gÃ¶nderilmeye Ã§alÄ±ÅŸÄ±ldÄ±ysa 
      // submitState'i kilitleyebilirsiniz (Bu Ã¶rnekte logluyoruz).
      this.logger.warn('Form is currently invalid. Please check fields.');
      
    } else if (newStatus === 'VALID') {
      
      // Form geÃ§erli hale geldi.
      this.logger.info('Form is now valid and ready to submit.');
    }
  });
```

**Bu neden reaktiftir?**
Siz formun durumunu sÃ¼rekli elle (`if (this.taskForm.invalid) ...`) kontrol etmiyorsunuz. Bunun yerine, formun durumu (`VALID` veya `INVALID`) *deÄŸiÅŸtiÄŸi anda* `statusChanges` akÄ±ÅŸÄ±nÄ±n size *haber vermesini* (tepki vermesini) bekliyorsunuz.


---

### ğŸ§  Soyutlama Olarak (Soru/Cevap Tablosu)

| Soru (Kafamdaki Soru) | Cevap (Reaktiflik) |
| :--- | :--- |
| **"Reaktif" ne demek?** | "DeÄŸiÅŸikliÄŸe tepki veren." |
| **Neye tepki veriyor?** | KullanÄ±cÄ±nÄ±n girdiÄŸi deÄŸere veya formun geÃ§erlilik durumunun (`valid`/`invalid`) deÄŸiÅŸmesine. |
| **"Tepki" tam olarak nerede?** | **1.** HTML (`View`) ve TypeScript (`Model`) arasÄ±ndaki anlÄ±k senkronizasyonda. <br> **2.** DeÄŸer ve durum deÄŸiÅŸikliklerini bir **RxJS Observable (`valueChanges`)** akÄ±ÅŸÄ± olarak sunmasÄ±nda. |
| **Neden Ã¶nemli?** | Ã‡Ã¼nkÃ¼ `valueChanges` akÄ±ÅŸÄ±na `pipe` ve `subscribe` olarak karmaÅŸÄ±k form mantÄ±klarÄ±nÄ± (anlÄ±k arama, dinamik doÄŸrulama vb.) Ã§ok temiz ve *bildirimsel* (declarative) bir yolla yÃ¶netebilirsiniz. |
















# 3) FormGroupm FormControl, Validators Yapilari

> Not: Ornekler icin feature-based todo projesinin task-create component'i baz alindi


### 1\. ğŸ¯ `FormControl` (Tek Bir AlanÄ±n Beyni)

#### "Ne"lik (Nedir?)

`FormControl`, Reactive Forms'un **en kÃ¼Ã§Ã¼k ve en temel** yapÄ± taÅŸÄ±dÄ±r. Bir formdaki **tek bir** alanÄ± (bir `<input>`, `<select>`, `<textarea>` veya `nz-date-picker`) temsil eder.

**GÃ¶revi:** O tek alanÄ±n...

  * DeÄŸerini (`value`)
  * GeÃ§erlilik durumunu (`valid` / `invalid`)
  * KullanÄ±cÄ± etkileÅŸimlerini (dokunuldu mu `touched`, deÄŸeri deÄŸiÅŸti mi `dirty`)

...takip etmek ve yÃ¶netmektir. Sizin projenizdeki `title` veya `priority` alanlarÄ±nÄ±n her biri bir `FormControl`'dÃ¼r.

#### âš™ï¸ SÄ±kÃ§a KullanÄ±lan Metot ve Ã–zellikleri

  * **`value` (Ã–zellik):** KontrolÃ¼n mevcut deÄŸerini verir. (Ã–rn: `"Raporu tamamla"`)
  * **`valid` / `invalid` (Ã–zellik):** KontrolÃ¼n, eklediÄŸiniz `Validators` kurallarÄ±na gÃ¶re geÃ§erli (`true`) veya geÃ§ersiz (`false`) olup olmadÄ±ÄŸÄ±nÄ± sÃ¶yler.
  * **`errors` (Ã–zellik):** EÄŸer kontrol *geÃ§ersizse*, hangi kuralÄ±n ihlal edildiÄŸini bir nesne olarak tutar (Ã¶rn: `{ required: true }`). GeÃ§erliyse `null`'dÄ±r.
  * **`touched` (Ã–zellik):** KullanÄ±cÄ± alana tÄ±klayÄ±p *dÄ±ÅŸarÄ± Ã§Ä±ktÄ±ÄŸÄ±nda* (blur) `true` olur. Hata mesajlarÄ±nÄ± sadece "dokunulmuÅŸ" alanlarda gÃ¶stermek iÃ§in kullanÄ±lÄ±r.
  * **`valueChanges` (Observable):** DeÄŸerin her deÄŸiÅŸimini (her tuÅŸ basÄ±mÄ±nÄ±) bir "akÄ±ÅŸ" (stream) olarak yayÄ±nlar.
  * **`patchValue(value)` (Metot):** KontrolÃ¼n deÄŸerini programatik olarak (kod iÃ§inden) deÄŸiÅŸtirir.
  * **`reset()` (Metot):** KontrolÃ¼ baÅŸlangÄ±Ã§ deÄŸerine (ve "dokunulmamÄ±ÅŸ", "kirletilmemiÅŸ" durumuna) dÃ¶ndÃ¼rÃ¼r.
  * **`setValidators(...)` / `clearValidators()` (Metotlar):** (Bir Ã¶nceki Ã¶rnekte gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z gibi) bir kontrolÃ¼n kurallarÄ±nÄ± dinamik olarak eklemek veya kaldÄ±rmak iÃ§in kullanÄ±lÄ±r.

#### ğŸš€ Tipik KullanÄ±m ve Ã–rnek

**Senaryo:** `task-create.component.ts`'deki `title` alanÄ±.

**1. TypeScript (`.ts`) DosyasÄ±nda OluÅŸturma:**
`initializeForm` metodunuzda, `title` iÃ§in bir `FormControl` Ã¶rneÄŸi (instance) oluÅŸturuyorsunuz.

```typescript
// .ts dosyasÄ±nda (initializeForm iÃ§inde):
title: new FormControl(
  '', // 1. BaÅŸlangÄ±Ã§ DeÄŸeri (BoÅŸ string)
  { // 2. Opsiyonlar
    nonNullable: true, // Asla null olmasÄ±n
    validators: [ // 3. Kurallar
      Validators.required,
      Validators.maxLength(200)
    ]
  }
)
```

**2. HTML (`.html`) DosyasÄ±nda BaÄŸlama:**
Bu `FormControl`'Ã¼, HTML'deki `<input>`'a `formControlName` direktifi ile baÄŸlÄ±yorsunuz.

```html
<input 
  nz-input 
  id="title"
  formControlName="title" maxlength="200" />
```

#### ğŸ’¡ Soyutlama CÃ¼mlesi

`FormControl`, formdaki tek bir kutucuÄŸun (input) deÄŸerini, geÃ§erliliÄŸini ve durumunu (dokunuldu mu, deÄŸiÅŸti mi) yÃ¶neten *en kÃ¼Ã§Ã¼k yapÄ± taÅŸÄ±dÄ±r*.

-----

### 2\. ğŸ¯ `FormGroup` (AlanlarÄ±n Konteyneri)

#### "Ne"lik (Nedir?)

`FormGroup`, birden fazla `FormControl`'Ã¼ (veya baÅŸka `FormGroup`'larÄ±) bir araya toplayan **konteynerdir**.

**GÃ¶revi:** Bir grup kontrolÃ¼ (`title`, `description`, `priority`...) mantÄ±ksal bir bÃ¼tÃ¼n olarak yÃ¶netmektir. Sizin `taskForm`'unuzun tamamÄ± bir `FormGroup`'tur.

  * EÄŸer grubun iÃ§indeki *tek bir* `FormControl` bile geÃ§ersizse (`invalid`), `FormGroup`'un *tamamÄ±* geÃ§ersiz (`invalid`) sayÄ±lÄ±r.
  * Grubun deÄŸerini (`value`) bir bÃ¼tÃ¼n olarak (JSON nesnesi gibi) size sunar.

#### âš™ï¸ SÄ±kÃ§a KullanÄ±lan Metot ve Ã–zellikleri

  * **`controls` (Ã–zellik):** Ä°Ã§indeki tÃ¼m `FormControl`'lere bir nesne olarak eriÅŸmenizi saÄŸlar (Ã¶rn: `this.taskForm.controls.title`).
  * **`value` (Ã–zellik):** Ä°Ã§indeki tÃ¼m kontrollerin deÄŸerlerini *tek bir nesne* olarak verir.
    ```json
    {
      "title": "Yeni GÃ¶rev",
      "description": "AÃ§Ä±klama...",
      "priority": 1,
      "dueDate": null
    }
    ```
  * **`valid` / `invalid` (Ã–zellik):** Grubun *tamamÄ±nÄ±n* geÃ§erli olup olmadÄ±ÄŸÄ±nÄ± sÃ¶yler.
  * **`get(path: string)` (Metot):** Bir alt kontrolÃ¼ isminden (string) gÃ¼venle Ã§aÄŸÄ±rmanÄ±n yoludur (Ã¶rn: `this.taskForm.get('title')`). `controls.title`'dan daha gÃ¼venli kabul edilir.
  * **`patchValue(value: object)` (Metot):** Formdaki *bazÄ±* alanlarÄ±n deÄŸerini (kÄ±smÃ® olarak) gÃ¼nceller. En sÄ±k kullanÄ±lan gÃ¼ncelleme metodudur.
  * **`reset()` (Metot):** Ä°Ã§indeki *tÃ¼m* kontrolleri sÄ±fÄ±rlar.

#### ğŸš€ Tipik KullanÄ±m ve Ã–rnek

**Senaryo:** `task-create.component.ts`'deki formun tamamÄ± (`taskForm`).

**1. TypeScript (`.ts`) DosyasÄ±nda OluÅŸturma:**
Form kontrollerinizi bir nesne iÃ§inde gruplayarak `taskForm`'u oluÅŸturuyorsunuz.

```typescript
interface TaskForm {
  title: FormControl<string>;
  description: FormControl<string>;
  priority: FormControl<Priority>;
  dueDate: FormControl<Date | null>;
}

//...

// .ts (initializeForm):
this.taskForm = new FormGroup<TaskForm>({
  // 'title' adÄ±nda bir anahtar (key) ve ona baÄŸlÄ± bir FormControl
  title: new FormControl('', ...), 
  
  // 'description' adÄ±nda bir anahtar (key) ve ona baÄŸlÄ± bir FormControl
  description: new FormControl('', ...), 
  
  // 'priority' adÄ±nda bir anahtar (key) ve ona baÄŸlÄ± bir FormControl
  priority: new FormControl(Priority.Medium, ...),
  
  dueDate: new FormControl<Date | null>(null, ...)
});
```

**2. HTML (`.html`) DosyasÄ±nda BaÄŸlama:**
Bu `FormGroup`'u, HTML'deki `<form>` etiketine `[formGroup]` direktifi ile baÄŸlÄ±yorsunuz.

```html
<form 
  nz-form 
  [formGroup]="taskForm" (ngSubmit)="submitForm()">
  
    <nz-form-item class="form-actions">
        <nz-form-control>
          <input formControlName="title" ... />
          <!-- ... -->
        </nz-form-control>
    </nz-form-item>

    <nz-form-item class="form-actions">
        <nz-form-control>
          <textarea formControlName="description" ... ></textarea>
          <!-- ... -->
        </nz-form-control>
    </nz-form-item>

    <nz-form-item class="form-actions">
        <nz-form-control>
          <nz-select formControlName="priority" ... ></nz-select>
          <!-- ... -->
        </nz-form-control>
    </nz-form-item>


</form>
```

**3. Submit (`.ts`) SÄ±rasÄ±nda KullanÄ±m:**
KullanÄ±cÄ± formu gÃ¶nderdiÄŸinde, grubun tamamÄ±nÄ±n geÃ§erliliÄŸini ve deÄŸerini kontrol edersiniz.

```typescript
// .ts (submitForm):
submitForm(): void {
  // 1. Grubun tamamÄ±nÄ±n geÃ§erliliÄŸini kontrol et
  if (this.taskForm.invalid) {
    return; // GeÃ§ersizse dur
  }
  
  // 2. Grubun tÃ¼m deÄŸerini al (patchValue/setValue'nun tersi)
  const title = this.taskForm.value.title!;
  const description = this.taskForm.value.description || null;
  
  // ...
  this.taskService.createTask(title, description, ...);
}
```

#### ğŸ’¡ Soyutlama CÃ¼mlesi

`FormGroup`, birden fazla `FormControl`'Ã¼ bir araya toplayan, grubun tamamÄ±nÄ±n deÄŸerini (`value`) ve geÃ§erliliÄŸini (`valid`) tek bir nesne olarak yÃ¶neten *konteynerdir*.

-----

### 3\. ğŸ¯ `Validators` (Kurallar)

#### "Ne"lik (Nedir?)

`Validators`, bir `FormControl`'e (veya `FormGroup`'a) eklenen **kural fonksiyonlarÄ±dÄ±r**.

Bunlar bir sÄ±nÄ±f veya nesne **deÄŸildir**. Sadece basit fonksiyonlardÄ±r.

**GÃ¶revi:** Bir `FormControl`'Ã¼n mevcut deÄŸerini alÄ±p kontrol etmektir.

  * EÄŸer deÄŸer kurala **uyuyorsa** -\> `null` dÃ¶ndÃ¼rÃ¼r (hata yok).
  * EÄŸer deÄŸer kurala **uymuyorsa** -\> bir *hata nesnesi* (error object) dÃ¶ndÃ¼rÃ¼r (Ã¶rn: `{ required: true }` veya `{ maxlength: ... }`).

Angular'Ä±n size `Validators` sÄ±nÄ±fÄ± altÄ±nda sunduÄŸu `required`, `maxLength` gibi hazÄ±r fonksiyonlarÄ± vardÄ±r.

#### âš™ï¸ SÄ±kÃ§a KullanÄ±lan HazÄ±r Validator'lar

Bunlar `Validators` sÄ±nÄ±fÄ±nÄ±n *statik* metotlarÄ±dÄ±r:

  * **`Validators.required`:** AlanÄ±n boÅŸ (`''`, `null`, `undefined`) olmamasÄ±nÄ± saÄŸlar.
  * **`Validators.maxLength(number)`:** DeÄŸerin belirli bir karakter uzunluÄŸunu geÃ§memesini saÄŸlar.
  * **`Validators.minLength(number)`:** DeÄŸerin belirli bir karakter uzunluÄŸundan az olmamasÄ±nÄ± saÄŸlar.
  * **`Validators.pattern(regex)`:** DeÄŸerin bir "regular expression" (regex) deseniyle eÅŸleÅŸmesini saÄŸlar (Ã¶rn: email formatÄ±, sadece sayÄ±).
  * **`Validators.email`:** Basit bir email formatÄ± kontrolÃ¼ yapar.

#### ğŸš€ Tipik KullanÄ±m ve Ã–rnek

**Senaryo:** `task-create.component.ts`'deki `title` alanÄ±nÄ±n "zorunlu" ve "max 200 karakter" olmasÄ±.

**1. TypeScript (`.ts`) DosyasÄ±nda TanÄ±mlama:**
`FormControl`'Ã¼ oluÅŸtururken `validators` dizisine bu fonksiyonlarÄ± eklersiniz.

```typescript
// .ts (initializeForm):
title: new FormControl('', {
  validators: [
    Validators.required, // Kural 1: Bu alan zorunludur
    Validators.maxLength(200) // Kural 2: Max 200 karakter olabilir
  ]
})
```

**2. HTML (`.html`) DosyasÄ±nda Hata GÃ¶sterme:**
HTML tarafÄ±nda, `FormControl`'Ã¼n `errors` Ã¶zelliÄŸini kontrol ederek (`control.hasError(...)` ile) uygun hata mesajÄ±nÄ± gÃ¶sterirsiniz.

Sizin kodunuzda bu, `@if` bloÄŸu ile Ã§ok modern bir ÅŸekilde yapÄ±lmÄ±ÅŸ:

```html
<ng-template #titleErrorTpl let-control>
  
  @if (control.hasError('required')) {
    GÃ¶rev baÅŸlÄ±ÄŸÄ± zorunludur
  }
  
  @if (control.hasError('maxlength')) {
    GÃ¶rev baÅŸlÄ±ÄŸÄ± en fazla 200 karakter olabilir
  }
</ng-template>
```

#### ğŸ’¡ Soyutlama CÃ¼mlesi

`Validators`, bir `FormControl`'e eklenen, verinin geÃ§erli olup olmadÄ±ÄŸÄ±nÄ± kontrol eden, geÃ§erliyse `null`, geÃ§ersizse bir *hata nesnesi* (Ã¶rn: `{ required: true }`) dÃ¶ndÃ¼ren *basit kural fonksiyonlarÄ±dÄ±r*.










