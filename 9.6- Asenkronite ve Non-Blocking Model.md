

# 1) 


## âš™ï¸ **6ï¸âƒ£ Asenkronite ve Non-Blocking Model**

### ğŸ“˜ 1. Kavramsal TanÄ±m

Klasik (senkron) programlama modellerinde:

> â€œBir iÅŸlem bitmeden diÄŸeri baÅŸlamaz.â€

Ancak reaktif sistemlerde:

> â€œBir iÅŸlem biterken diÄŸerini **beklemeden** baÅŸlatabilirsin.â€

Yani sistem **bloklamaz**, sadece **olaylarÄ± dinler**.
Bir akÄ±ÅŸtan veri geldiÄŸinde, o anda **tepki verir** (react).

ğŸ’¡ **Soyut tanÄ±m:**

> â€œBeklemek yerine olaylarÄ± dinle.â€

---

### âš¡ 2. Non-Blocking AkÄ±ÅŸÄ±n MantÄ±ÄŸÄ±

Reaktif sistemde, her iÅŸlem bir â€œstreamâ€dir.
Ä°ÅŸlem A uzun sÃ¼rÃ¼yorsa, B onu **beklemeden** devam eder; A bittiÄŸinde sadece **emit** eder ve akÄ±ÅŸ **abone olan** kÄ±sÄ±mlarÄ± tetikler.

```ts
import { of, delay } from 'rxjs';

of('A iÅŸlemi tamamlandÄ±')
  .pipe(delay(2000)) // 2 saniye sonra yayÄ±na girer
  .subscribe(value => console.log(value));

console.log('B iÅŸlemi baÅŸladÄ±');
```

ğŸ“¤ **Konsol Ã§Ä±ktÄ±sÄ±:**

```
B iÅŸlemi baÅŸladÄ±
A iÅŸlemi tamamlandÄ±
```

â¡ï¸ GÃ¶rdÃ¼ÄŸÃ¼n gibi â€œAâ€ iÅŸlemi 2 saniye sÃ¼rse bile â€œBâ€ bloklanmadÄ±.
Bu, reaktif sistemin **non-blocking (engellemeyen)** doÄŸasÄ±dÄ±r.

---

### ğŸ§© 3. Zaman YÃ¶netimi OperatÃ¶rleri

Reaktif sistemlerde zaman, akÄ±ÅŸÄ±n **bir parÃ§asÄ±** olarak yÃ¶netilir.
Yani â€œbeklemeâ€ veya â€œgecikmeâ€ ayrÄ± bir yapÄ± deÄŸildir; operatÃ¶rlerle akÄ±ÅŸÄ±n iÃ§ine gÃ¶mÃ¼lÃ¼r:

| OperatÃ¶r           | AÃ§Ä±klama                                                                     |
| ------------------ | ---------------------------------------------------------------------------- |
| `delay(ms)`        | AkÄ±ÅŸÄ± belirli sÃ¼re geciktirir                                                |
| `debounceTime(ms)` | Son emitâ€™ten sonra belirli sÃ¼re sessizlik olursa yeni deÄŸeri yayar           |
| `throttleTime(ms)` | Belirli aralÄ±klarla emit etmeye izin verir (Ã¶rneÄŸin kullanÄ±cÄ± inputâ€™larÄ±nda) |
| `interval(ms)`     | Belirli aralÄ±klarla sÃ¼rekli veri Ã¼retir                                      |
| `timer(ms)`        | Belirli bir sÃ¼re sonra **tek seferlik** emit yapar                           |

---

### ğŸ’» 4. GerÃ§ek Hayat Ã–rneÄŸi â€” Reactive Search

KullanÄ±cÄ± inputâ€™una her tuÅŸ basÄ±ÅŸta API Ã§aÄŸrÄ±sÄ± yapmak performanslÄ± deÄŸildir.
Reaktif modelde `debounceTime()` ile yalnÄ±zca **kullanÄ±cÄ± yazmayÄ± bÄ±rakÄ±nca** Ã§aÄŸrÄ± yapÄ±lÄ±r:

```ts
this.searchControl.valueChanges
  .pipe(
    debounceTime(400),
    switchMap(value => this.api.search(value))
  )
  .subscribe(results => this.searchResults = results);
```

â¡ï¸ Bu yapÄ±:

* Her tuÅŸ basÄ±ÅŸÄ±nÄ± dinler,
* 400 ms boyunca yeni deÄŸer gelmezse **emit eder**,
* APIâ€™ye tek istek gÃ¶nderir (boÅŸuna yÃ¼klenmez).

---

### âœ… 5. Best Practice

| Prensip                                   | AÃ§Ä±klama                                                     |
| ----------------------------------------- | ------------------------------------------------------------ |
| **1. AsenkronluÄŸu embrace et**            | Bekleme yerine tepkisel (reactive) dÃ¼ÅŸÃ¼n.                    |
| **2. Zaman yÃ¶netimini operatÃ¶rlerle yap** | setTimeout deÄŸil, `delay` / `debounceTime` kullan.           |
| **3. Ä°ÅŸlemleri paralel ama tutarlÄ± tut**  | combineLatest / switchMap ile akÄ±ÅŸlarÄ± senkronize et.        |
| **4. UI'yi engelleme**                    | Spinner veya progress barâ€™larÄ± ayrÄ± streamâ€™lerde kontrol et. |

---

### ğŸ’¡ Soyutlama CÃ¼mlesi

> Reaktif sistemler zamanÄ± â€œbeklemeâ€ olarak deÄŸil, â€œolay sÄ±rasÄ±â€ olarak gÃ¶rÃ¼r.
> Kod satÄ±r satÄ±r deÄŸil, **veri akÄ±ÅŸÄ±na tepki olarak** Ã§alÄ±ÅŸÄ±r.
> BÃ¶ylece sistem aynÄ± anda birÃ§ok akÄ±ÅŸla ilgilenebilir â€” **bloklamadan, tÄ±kanmadan.**

---
