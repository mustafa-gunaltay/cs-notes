

# 1) 


## ⚙️ **6️⃣ Asenkronite ve Non-Blocking Model**

### 📘 1. Kavramsal Tanım

Klasik (senkron) programlama modellerinde:

> “Bir işlem bitmeden diğeri başlamaz.”

Ancak reaktif sistemlerde:

> “Bir işlem biterken diğerini **beklemeden** başlatabilirsin.”

Yani sistem **bloklamaz**, sadece **olayları dinler**.
Bir akıştan veri geldiğinde, o anda **tepki verir** (react).

💡 **Soyut tanım:**

> “Beklemek yerine olayları dinle.”

---

### ⚡ 2. Non-Blocking Akışın Mantığı

Reaktif sistemde, her işlem bir “stream”dir.
İşlem A uzun sürüyorsa, B onu **beklemeden** devam eder; A bittiğinde sadece **emit** eder ve akış **abone olan** kısımları tetikler.

```ts
import { of, delay } from 'rxjs';

of('A işlemi tamamlandı')
  .pipe(delay(2000)) // 2 saniye sonra yayına girer
  .subscribe(value => console.log(value));

console.log('B işlemi başladı');
```

📤 **Konsol çıktısı:**

```
B işlemi başladı
A işlemi tamamlandı
```

➡️ Gördüğün gibi “A” işlemi 2 saniye sürse bile “B” bloklanmadı.
Bu, reaktif sistemin **non-blocking (engellemeyen)** doğasıdır.

---

### 🧩 3. Zaman Yönetimi Operatörleri

Reaktif sistemlerde zaman, akışın **bir parçası** olarak yönetilir.
Yani “bekleme” veya “gecikme” ayrı bir yapı değildir; operatörlerle akışın içine gömülür:

| Operatör           | Açıklama                                                                     |
| ------------------ | ---------------------------------------------------------------------------- |
| `delay(ms)`        | Akışı belirli süre geciktirir                                                |
| `debounceTime(ms)` | Son emit’ten sonra belirli süre sessizlik olursa yeni değeri yayar           |
| `throttleTime(ms)` | Belirli aralıklarla emit etmeye izin verir (örneğin kullanıcı input’larında) |
| `interval(ms)`     | Belirli aralıklarla sürekli veri üretir                                      |
| `timer(ms)`        | Belirli bir süre sonra **tek seferlik** emit yapar                           |

---

### 💻 4. Gerçek Hayat Örneği — Reactive Search

Kullanıcı input’una her tuş basışta API çağrısı yapmak performanslı değildir.
Reaktif modelde `debounceTime()` ile yalnızca **kullanıcı yazmayı bırakınca** çağrı yapılır:

```ts
this.searchControl.valueChanges
  .pipe(
    debounceTime(400),
    switchMap(value => this.api.search(value))
  )
  .subscribe(results => this.searchResults = results);
```

➡️ Bu yapı:

* Her tuş basışını dinler,
* 400 ms boyunca yeni değer gelmezse **emit eder**,
* API’ye tek istek gönderir (boşuna yüklenmez).

---

### ✅ 5. Best Practice

| Prensip                                   | Açıklama                                                     |
| ----------------------------------------- | ------------------------------------------------------------ |
| **1. Asenkronluğu embrace et**            | Bekleme yerine tepkisel (reactive) düşün.                    |
| **2. Zaman yönetimini operatörlerle yap** | setTimeout değil, `delay` / `debounceTime` kullan.           |
| **3. İşlemleri paralel ama tutarlı tut**  | combineLatest / switchMap ile akışları senkronize et.        |
| **4. UI'yi engelleme**                    | Spinner veya progress bar’ları ayrı stream’lerde kontrol et. |

---

### 💡 Soyutlama Cümlesi

> Reaktif sistemler zamanı “bekleme” olarak değil, “olay sırası” olarak görür.
> Kod satır satır değil, **veri akışına tepki olarak** çalışır.
> Böylece sistem aynı anda birçok akışla ilgilenebilir — **bloklamadan, tıkanmadan.**

---
