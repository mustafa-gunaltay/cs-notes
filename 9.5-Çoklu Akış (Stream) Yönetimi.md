

# 0) Coklu Akis Yonetimi nedir

### ğŸ“˜ 1. Kavramsal TanÄ±m

GerÃ§ek bir uygulamada genelde **birden fazla veri kaynaÄŸÄ± (stream)** vardÄ±r:
Ã¶rneÄŸin,

* bir **kullanÄ±cÄ±nÄ±n seÃ§imleri (dropdown, checkbox, input)**
* bir **API yanÄ±tÄ± (HTTP Observable)**
* veya bir **timer / sensÃ¶r akÄ±ÅŸÄ±**

Bu akÄ±ÅŸlar **baÄŸÄ±msÄ±z** ama **birbiriyle iliÅŸkili** olabilir.
Ä°ÅŸte `combineLatest()` gibi operatÃ¶rler, bu birden fazla akÄ±ÅŸÄ± **senkronize edip tek bir birleÅŸik akÄ±ÅŸ** haline getirir.

> ğŸ’¡ **Soyut tanÄ±m:**
> â€œBirden fazla veri kaynaÄŸÄ±nÄ± aynÄ± zaman ekseninde hizala.â€

---




# 1) combineLatest

### ğŸ“˜ 1. Kavramsal TanÄ±m

GerÃ§ek bir uygulamada genelde **birden fazla veri kaynaÄŸÄ± (stream)** vardÄ±r:
Ã¶rneÄŸin,

* bir **kullanÄ±cÄ±nÄ±n seÃ§imleri (dropdown, checkbox, input)**
* bir **API yanÄ±tÄ± (HTTP Observable)**
* veya bir **timer / sensÃ¶r akÄ±ÅŸÄ±**

Bu akÄ±ÅŸlar **baÄŸÄ±msÄ±z** ama **birbiriyle iliÅŸkili** olabilir.
Ä°ÅŸte `combineLatest()` gibi operatÃ¶rler, bu birden fazla akÄ±ÅŸÄ± **senkronize edip tek bir birleÅŸik akÄ±ÅŸ** haline getirir.

> ğŸ’¡ **Soyut tanÄ±m:**
> â€œBirden fazla veri kaynaÄŸÄ±nÄ± aynÄ± zaman ekseninde hizala.â€

---

### âš™ï¸ 2. Temel KullanÄ±m

```ts
import { combineLatest, of } from 'rxjs';
import { map } from 'rxjs/operators';

const name$ = of('Mustafa');
const age$ = of(22);

combineLatest([name$, age$])
  .pipe(map(([name, age]) => `${name} is ${age} years old`))
  .subscribe(console.log);
```

ğŸ§  **AÃ§Ä±klama:**

* Her Observable (`name$`, `age$`) bir deÄŸer *emit* eder.
* `combineLatest()` â†’ her biri yeni deÄŸer Ã¼rettiÄŸinde, **tÃ¼m son deÄŸerleri alÄ±r** ve bir **dizi olarak** dÃ¶ner.
* Bu dizi (`[name, age]`) `map()` ile birleÅŸtirilip tek bir anlamlÄ± Ã§Ä±ktÄ± haline gelir.

ğŸ“¤ **Ã‡Ä±ktÄ±:**

```
Mustafa is 22 years old
```

---

### ğŸ”„ 3. Reaktif AkÄ±ÅŸ MantÄ±ÄŸÄ±

```
name$   :   Mustafa â”€â”€â”€â”€â”€â”€â”€â”€â†’
age$    :   22 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
combine :   [Mustafa, 22] â”€â”€â†’ map() â†’ "Mustafa is 22 years old"
```

> Yani, her akÄ±ÅŸ kendi zamanÄ±nda Ã§alÄ±ÅŸsa bile,
> `combineLatest()` onlarÄ± **en son deÄŸerleriyle** senkronize eder.

---

### âš¡ 4. GerÃ§ek Hayat Ã–rneÄŸi (Angular)

```ts
combineLatest([
  this.selectedCategory$,
  this.categoryService.getProducts()
]).pipe(
  map(([category, products]) =>
    products.filter(p => p.categoryId === category.id)
  )
).subscribe(filtered => this.displayedProducts = filtered);
```

ğŸ§  **Ne oluyor:**

* KullanÄ±cÄ± kategori seÃ§tiÄŸinde `selectedCategory$` yeni bir deÄŸer *emit* ediyor.
* APIâ€™den Ã¼rÃ¼n listesi geldiÄŸinde `getProducts()` yeni bir deÄŸer *emit* ediyor.
* `combineLatest()` bu iki akÄ±ÅŸÄ± **senkronize ediyor** â†’
  yeni kategori seÃ§ildiÄŸinde veya Ã¼rÃ¼n listesi yenilendiÄŸinde gÃ¶rÃ¼nÃ¼m (UI) reaktif olarak gÃ¼ncelleniyor.

---

### âœ… 5. Best Practiceâ€™ler

| Prensip                                                                                | AÃ§Ä±klama                                                                                   |
| -------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| **1. combineLatest yalnÄ±zca her Observable en az bir kez emit ettikten sonra Ã§alÄ±ÅŸÄ±r** | Yani baÅŸlangÄ±Ã§ta hiÃ§bir deÄŸer yoksa tetiklenmez.                                           |
| **2. `map()` veya `switchMap()` ile birlikte kullan**                                  | BÃ¶ylece veriyi dÃ¶nÃ¼ÅŸtÃ¼rÃ¼p UIâ€™a uygun hale getirebilirsin.                                  |
| **3. `startWith()` ekleyerek ilk deÄŸeri garanti et**                                   | BoÅŸ durumlarda UIâ€™in donmamasÄ± iÃ§in.                                                       |
| **4. Tek sorumluluk**                                                                  | combineLatest yalnÄ±zca â€œeÅŸzamanlamaâ€ iÃ§in kullanÄ±lmalÄ±, dÃ¶nÃ¼ÅŸÃ¼m iÅŸi `map()`â€™e bÄ±rakÄ±lmalÄ±. |

---

### ğŸ’¡ Soyutlama CÃ¼mlesi

> â€œ`combineLatest()` reaktif sistemin senkronizasyon katmanÄ±dÄ±r.
> Birden fazla baÄŸÄ±msÄ±z akÄ±ÅŸÄ± aynÄ± anda izler,
> ve her biri yeni deÄŸer Ã¼rettiÄŸinde birleÅŸik bir tepki (reaksiyon) oluÅŸturur.â€

---




### Gercek Hayat Ornegi

```ts
export default class ArticleComponent implements OnInit {
  article!: Article;
  currentUser!: User | null;
  comments: Comment[] = [];
  canModify: boolean = false;

  commentControl = new FormControl<string>("", { nonNullable: true });
  commentFormErrors: Errors | null = null;

  isSubmitting = false;
  isDeleting = false;
  destroyRef = inject(DestroyRef);

  constructor(
    private readonly route: ActivatedRoute,
    private readonly articleService: ArticlesService,
    private readonly commentsService: CommentsService,
    private readonly router: Router,
    private readonly userService: UserService,
  ) {}

  ngOnInit(): void {
    const slug = this.route.snapshot.params["slug"];
    combineLatest([
      this.articleService.get(slug),
      this.commentsService.getAll(slug),
      this.userService.currentUser,
    ])
      .pipe(
        catchError((err) => {
          void this.router.navigate(["/"]);
          return throwError(() => err);
        }),
        takeUntilDestroyed(this.destroyRef),
      )
      .subscribe(([article, comments, currentUser]) => {
        this.article = article;
        this.comments = comments;
        this.currentUser = currentUser;
        this.canModify = currentUser?.username === article.author.username;
      });
  }

...
}
```

- Gercek hayattaki bir makale sayfasi -> makale verisi, makale yorumlarÄ± ve mevcut kullanÄ±cÄ± bir butundur. Dolayisiyla bunlardan herhangi biri degistiginde hepsinin ayni anda guncellenmesi ( birbirine bagli sekilde handle edilmesi) gerekir. 
- Ornegin makale (slug) deÄŸiÅŸirse, makale verisi ve o makalenin yorumlarÄ± yeniden yÃ¼klenmelidir. 






# 2) forkJoin

---

## âœ… `forkJoin` nedir?

`forkJoin`, **tÃ¼m Observableâ€™lar tamamlandÄ±ÄŸÄ±nda** (complete olduÄŸunda) **tek bir sonuÃ§** dÃ¶ndÃ¼ren bir RxJS operatÃ¶rÃ¼dÃ¼r.

ğŸ“Œ Yani:

* â€œHepsi bitsin, Ã¶yle devam edelimâ€ senaryosu iÃ§in kullanÄ±lÄ±r.
* Promiseâ€™lerdeki `Promise.all` yapÄ±sÄ±nÄ±n **RxJS karÅŸÄ±lÄ±ÄŸÄ±dÄ±r**.
* En sÄ±k **Ã§oklu HTTP isteÄŸi yapÄ±p sonuÃ§larÄ± birleÅŸtirmek** iÃ§in kullanÄ±lÄ±r.

---

## âœ… `forkJoin` nasÄ±l Ã§alÄ±ÅŸÄ±r?

* Ä°Ã§ine verdiÄŸin her Observable'Ä±n **bitmesini bekler**.
* Her Observableâ€™Ä±n **son deÄŸerini** alÄ±r.
* **Tek sefer** deÄŸer yayÄ±nlar ve **tamamlanÄ±r**.

---

## âœ… KullanÄ±mÄ±

### ğŸ‘ En basit Ã¶rnek

```ts
import { forkJoin } from 'rxjs';

forkJoin([
  of(1),
  of(2),
  of(3)
]).subscribe(result => {
  console.log(result); // [1, 2, 3]
});
```

### âœ… GerÃ§ek kullanÄ±m â€“ Ã§oklu HTTP isteÄŸi

```ts
forkJoin({
  user: this.http.get('/api/user/10'),
  posts: this.http.get('/api/user/10/posts'),
  comments: this.http.get('/api/user/10/comments'),
}).subscribe(result => {
  console.log(result.user);
  console.log(result.posts);
  console.log(result.comments);
});
```

---

## âš ï¸ Ã–nemli Ã¶zellikler

| Ã–zellik                | AÃ§Ä±klama                                                     |
| ---------------------- | ------------------------------------------------------------ |
| **Tek yayÄ±n yapar**    | Hepsi bitince 1 kez emit eder                                |
| **Completion zorunlu** | EÄŸer bir Observable hiÃ§ `complete` etmezse forkJoin Ã§alÄ±ÅŸmaz |
| **Son deÄŸerleri alÄ±r** | Observableâ€™larÄ±n sadece *en son deÄŸerini* alÄ±r               |
| **HTTP ile uyumlu**    | Ã‡Ã¼nkÃ¼ HTTP istekleri zaten `complete` olur                   |

---


## ğŸ¯ Senaryo (forkJoin ve combineLatest icin ayni Ã¶rnek)

Bir e-ticaret uygulamasÄ± dÃ¼ÅŸÃ¼nelim. KullanÄ±cÄ± bir Ã¼rÃ¼n sayfasÄ±na girdiÄŸinde:

âœ… 2 API Ã§aÄŸrÄ±sÄ± yapÄ±lacak:

1. `getProduct()` â†’ ÃœrÃ¼nÃ¼n detaylarÄ±nÄ± getirir
2. `getStock()` â†’ ÃœrÃ¼nÃ¼n stok bilgisini getirir

```ts
getProduct(id) // Ã–rn: { id: 10, name: "Laptop", price: 15000 }
getStock(id)   // Ã–rn: { productId: 10, inStock: true }
```

---

### âœ… forkJoin ile kullanÄ±m (HTTP iÃ§in ideal)

```ts
forkJoin({
  product: this.api.getProduct(10),
  stock: this.api.getStock(10)
}).subscribe(result => {
  console.log('ÃœrÃ¼n:', result.product);
  console.log('Stok:', result.stock);
});
```

#### âœ… Ne olur?

| Ã–zellik             | forkJoin davranÄ±ÅŸÄ±                                           |
| ------------------- | ------------------------------------------------------------ |
| Ne zaman Ã§alÄ±ÅŸÄ±r?   | Her iki istek **bitince**                                    |
| KaÃ§ kere emit eder? | **1 kez**                                                    |
| Use case            | Ä°lk yÃ¼kleme â€“ sayfayÄ± aÃ§arken ihtiyacÄ±mÄ±z olan final veri    |
| Uygun mu?           | âœ… Ã‡ok uygun â€“ HTTP istekleri zaten 1 kez dÃ¶ner ve tamamlanÄ±r |

---

### ğŸ”„ combineLatest ile aynÄ± senaryo

```ts
combineLatest({
  product: this.api.getProduct(10),
  stock: this.api.getStock(10)
}).subscribe(result => {
  console.log('ÃœrÃ¼n:', result.product);
  console.log('Stok:', result.stock);
});
```

#### â— Ne olur?

| Ã–zellik             | combineLatest davranÄ±ÅŸÄ±                              |
| ------------------- | ---------------------------------------------------- |
| Ne zaman Ã§alÄ±ÅŸÄ±r?   | Her iki stream **ilk deÄŸerini Ã¼rettikten sonra**     |
| KaÃ§ kere emit eder? | **Her yeni deÄŸer geldiÄŸinde tekrar**                 |
| Use case            | Genelde **sÃ¼rekli gÃ¼ncellenen veri** akÄ±ÅŸÄ±           |
| Uygun mu?           | âŒ HTTP iÃ§in mantÄ±ksÄ±z â€“ Ã§Ã¼nkÃ¼ HTTP tekrar etmez      |
| Sorun               | `stock` tekrar deÄŸiÅŸmezse combineLatest sessiz kalÄ±r |

---


## â— Davranis Farki Ozeti

| Ã–zellik          | `forkJoin`                          | `combineLatest`                                   |
| ---------------- | ----------------------------------- | ------------------------------------------------- |
| Publish zamanÄ±   | TÃ¼m kaynaklar bitince **tek sefer** | Ä°lk deÄŸerlerden sonra **her deÄŸiÅŸimde emit eder** |
| KullanÄ±m amacÄ±   | â€œHepsi bitsin, sonucu birleÅŸtirâ€    | â€œSon durumlarÄ± birlikte takip etâ€                 |
| Completion ÅŸartÄ± | Evet, hepsi complete olmalÄ±         | HayÄ±r                                             |
| DeÄŸer tipi       | Son deÄŸerleri verir                 | En gÃ¼ncel deÄŸerleri sÃ¼rekli verir                 |
| YayÄ±n sayÄ±sÄ±     | 1                                   | SÃ¼rekli                                           |
| En iyi kullanÄ±m  | Ã‡oklu HTTP                          | Form birleÅŸimi, UI state, reaktif hesaplama       |

---


## ğŸ‘‡ Ã–zet cÃ¼mle

> âœ… **`forkJoin` = Promise.all gibi â†’ "Hepsi bitsin, sonucu ver"**

> ğŸ”„ **`combineLatest` = "Hangisi deÄŸiÅŸirse deÄŸiÅŸsin, en son halleri birlikte ver"**

---







# 3) DiÄŸer Ã‡oklu AkÄ±ÅŸ YÃ¶netim MekanizmalarÄ±

Bu baÅŸlÄ±k altÄ±na **combineLatest** ve **forkJoin** dÄ±ÅŸÄ±nda kalan Ã¶nemli RxJS operatÃ¶rlerini ekleyebiliriz. Hepsi "multiple observable streams" yani **Ã§oklu observable akÄ±ÅŸlarÄ±nÄ± yÃ¶netme stratejileri** altÄ±nda toplanÄ±r. 

---

### ğŸ”§ 3.1 `zip`

**Ne yapar?**
Birden fazla observableâ€™dan gelen verileri **sÄ±ra numaralarÄ±na gÃ¶re eÅŸleÅŸtirir**. Yani her akÄ±ÅŸtan **aynÄ± indexâ€™teki deÄŸerleri** birleÅŸtirir.

**En iyi kullanÄ±m alanÄ±:**
Senkron eÅŸleÅŸen veri iÅŸlemleri â€“ Ã¶rneÄŸin: kullanÄ±cÄ± isimleri + kullanÄ±cÄ± yaÅŸlarÄ± iki ayrÄ± akÄ±ÅŸtan geliyorsa indexâ€™e gÃ¶re eÅŸleÅŸtirilebilir.

---

### ğŸ” 3.2 `merge`

**Ne yapar?**
Birden fazla observableâ€™Ä± **tek observable gibi birleÅŸtirir**, veriler **hangisinden gelirse gelsin tek stream** olarak akar.

**En iyi kullanÄ±m alanÄ±:**
Birden fazla kaynaktan veri akÄ±yorsa ve **sÄ±ra Ã¶nemli deÄŸilse**, akÄ±ÅŸlarÄ± birleÅŸtirmek iÃ§in.

---

### ğŸ”€ 3.3 `concat`

**Ne yapar?**
Observableâ€™larÄ± **sÄ±rasÄ±yla** Ã§alÄ±ÅŸtÄ±rÄ±r. Ä°lk observable tamamlanmadan diÄŸerine geÃ§mez.

**En iyi kullanÄ±m alanÄ±:**
**AdÄ±m adÄ±m ardÄ±ÅŸÄ±k sÃ¼reÃ§ler** â€“ Ã¶rneÄŸin Ã¶nce kullanÄ±cÄ± login olacak, sonra profil yÃ¼klenecek.

---

### âš¡ 3.4 `switchMap`

**Ne yapar?**
Yeni bir akÄ±ÅŸ baÅŸlatÄ±ldÄ±ÄŸÄ±nda **Ã¶ncekini iptal eder ve stream'i (stream tipini) deÄŸiÅŸtirir**.

**En iyi kullanÄ±m alanÄ±:**
**Arama kutusu (autocomplete)** gibi sÃ¼rekli deÄŸiÅŸen isteklerde eski istekleri iptal etmek iÃ§in.

---

### ğŸ” 3.5 `mergeMap` (flatMap)

**Ne yapar?**
Gelen her veriye karÅŸÄ±lÄ±k **eÅŸzamanlÄ± yeni bir observable baÅŸlatÄ±r** ve hepsini tek akÄ±ÅŸta toplar. Paralel Ã§alÄ±ÅŸÄ±r.

**En iyi kullanÄ±m alanÄ±:**
AynÄ± anda **Ã§oklu paralel HTTP istekleri** veya event iÅŸleme.

---

### ğŸ”— 3.6 `concatMap`

**Ne yapar?**
Gelen her veriyi **sÄ±rayla** iÅŸler, Ã¶nceki bitmeden yenisini baÅŸlatmaz.

**En iyi kullanÄ±m alanÄ±:**
**Kuyruklama iÅŸlemleri** â€“ Ã–rn: sipariÅŸ iÅŸlemleri sÄ±rayla iÅŸlenmeli.

---

### â— 3.7 `exhaustMap`

**Ne yapar?**
Bir iÅŸlem sÃ¼rerken **yeni gelen istekleri yok sayar**.

**En iyi kullanÄ±m alanÄ±:**
**Butona spam tÄ±klama engellemek** â€“ bir HTTP isteÄŸi sÃ¼rerken diÄŸerlerini gÃ¶rmezden gelir.

---

### âœ… Ã–zet Tablo

| OperatÃ¶r      | AmaÃ§                             | SÄ±ra Garantisi | Paralel | Ã–zel DavranÄ±ÅŸ                |
| ------------- | -------------------------------- | -------------- | ------- | ---------------------------- |
| combineLatest | En son deÄŸerleri birleÅŸtirir     | âŒ              | âœ…       | Hepsi en az 1 deÄŸer Ã¼retmeli |
| forkJoin      | Son deÄŸerler tamamlanÄ±nca        | âœ…              | âœ…       | Observableâ€™lar bitmeli       |
| zip           | Indexâ€™e gÃ¶re eÅŸleÅŸtirir          | âœ…              | âœ…       | AynÄ± sÄ±ra ile                |
| merge         | AkÄ±ÅŸlarÄ± birleÅŸtirir             | âŒ              | âœ…       | Ã‡akÄ±ÅŸan akÄ±ÅŸlar              |
| concat        | SÄ±ra ile Ã§alÄ±ÅŸtÄ±rÄ±r              | âœ…              | âŒ       | Ä°lk bitmeden diÄŸerine geÃ§mez |
| switchMap     | Ã–nceki iptal edilir              | âŒ              | âœ…       | Autocomplete iÃ§in ideal      |
| mergeMap      | Hepsini paralel Ã§alÄ±ÅŸtÄ±rÄ±r       | âŒ              | âœ…       | Ã‡oklu HTTP paralel           |
| concatMap     | SÄ±rayla Ã§alÄ±ÅŸtÄ±rÄ±r               | âœ…              | âŒ       | Kuyruklama iÃ§in              |
| exhaustMap    | Devam ederken yenisini yok sayar | âŒ              | âŒ       | Spam iÅŸlem engelleme         |

---



# 4) Coklu Akis Yonetimi Yapilari Hizli Notlar

## 1) switchMap
```ts
this.userService.currentUser
      .pipe(
        // currentUser her degistiginde null mi diye kontrol et 
        // (herhangi bir kullanici login degilse ayni null'sa) ise 
        // kategorileri temizle
        filter((user) => {
          // KullanÄ±cÄ± yoksa (logout durumu) kategorileri temizle
          if (!user) {
            this.logger.warn('KullanÄ±cÄ± bilgisi yok, kategoriler temizleniyor', {}, 'CategoryListComponent');
            this.categories = [];
            this.currentUser = null;
            this.loading = false;
          }
          return !!user; // Sadece user varsa devam et
        }),
        // currentUser her deÄŸiÅŸtiÄŸinde currentUser seklinde akan stream'i 
        // "this.categoryService.getCategoriesByUserId(currentUser.id)" den
        // donen stream ile degistir. 
        // Eski currentUser stream'i iptal edilir ve yerine 
        // yeni kategori stream'i gelerek stream devam eder
        // Ornegin catchError kategori stream'inden gelen hatalari yakalar
        switchMap((currentUser) => {
          // currentUser state'ini gÃ¼ncelle
          this.currentUser = currentUser;
          
          this.logger.debug('CurrentUser alÄ±ndÄ±, kategoriler yÃ¼kleniyor', { 
            userId: currentUser.id, 
            email: currentUser.email 
          }, 'CategoryListComponent');
          
          // userId ile kategorileri yÃ¼kle
          return this.categoryService.getCategoriesByUserId(currentUser.id);
        }),
        catchError((err) => {
          this.logger.error('Veri yÃ¼kleme hatasÄ±', { error: err }, 'CategoryListComponent');
          this.errors = this.errorHandler.handleHttpError(err);
          this.loading = false;
          return throwError(() => err);
        }),
        takeUntilDestroyed(this.destroyRef)
      )
      .subscribe({
        next: (categories) => {
          this.logger.info('Veriler baÅŸarÄ±yla yÃ¼klendi', { 
            count: categories.length,
            userId: this.currentUser?.id 
          }, 'CategoryListComponent');
          
          this.categories = categories;
          this.loading = false;
        },
        error: (error) => {
          this.logger.error('Subscribe error', { error }, 'CategoryListComponent');
          this.loading = false;
        }
      });
```


`switchMap`'i anlamanÄ±n en iyi yolu, onu "haritalamak" (map) ve "deÄŸiÅŸtirmek/geÃ§iÅŸ yapmak" (switch) olarak iki parÃ§ada dÃ¼ÅŸÃ¼nmektir.

* **Map (Haritalama) KÄ±smÄ±:** TÄ±pkÄ± normal `.map()` operatÃ¶rÃ¼ gibi, bir deÄŸeri alÄ±r (bizim Ã¶rneÄŸimizde `currentUser` nesnesi) ve onu **baÅŸka bir ÅŸeye** dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r.
* **Switch (GeÃ§iÅŸ) KÄ±smÄ±:** `switchMap`'in farkÄ± ÅŸudur: DÃ¶nÃ¼ÅŸtÃ¼rdÃ¼ÄŸÃ¼ "baÅŸka ÅŸey" **yeni bir Observable (yeni bir akÄ±ÅŸ) olmalÄ±dÄ±r.** Bizim Ã¶rneÄŸimizde bu yeni akÄ±ÅŸ: `this.categoryService.getCategoriesByUserId(currentUser.id)` (yani API'den kategorileri getiren HTTP isteÄŸi).

`switchMap` bu iki akÄ±ÅŸÄ± (dÄ±ÅŸ ve iÃ§) yÃ¶netir:

1.  **DÄ±ÅŸ AkÄ±ÅŸ (Outer Observable):** `this.userService.currentUser` akÄ±ÅŸÄ±nÄ±z. Bu akÄ±ÅŸ, kullanÄ±cÄ± giriÅŸ/Ã§Ä±kÄ±ÅŸ yaptÄ±kÃ§a yeni deÄŸerler (`User` nesnesi or `null`) yayÄ±nlar. Bu, "uzun Ã¶mÃ¼rlÃ¼" bir akÄ±ÅŸtÄ±r; component hayatta olduÄŸu sÃ¼rece devam eder.
2.  **Ä°Ã§ AkÄ±ÅŸ (Inner Observable):** `this.categoryService.getCategoriesByUserId(...)` akÄ±ÅŸÄ±. Bu, "kÄ±sa Ã¶mÃ¼rlÃ¼" bir akÄ±ÅŸtÄ±r. BaÅŸlar (HTTP isteÄŸi gider), bir deÄŸer (kategori dizisi) dÃ¶ndÃ¼rÃ¼r ve biter (complete).

