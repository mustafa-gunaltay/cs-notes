

# 1)

## 🧩 1. Kavramsal Tanım

**Sibling / Dağıtık Component iletişimi**, aynı seviyedeki veya birbirinden bağımsız component’lerin **ortak bir servis aracılığıyla veri paylaşmasıdır.**

> Angular component’leri birbirinden izole çalışır;
> Bu nedenle, component ağacı içinde doğrudan bağlantısı olmayan component’ler **servis üzerinden dolaylı (indirect) iletişim kurar.**

---

## ⚙️ 2. Neden Servis Kullanılır?

`@Input()` ve `@Output()` sadece **ebeveyn → çocuk** veya **çocuk → ebeveyn** iletişimi sağlar.
Ama şu durumlarda işe yaramaz:

* İki farklı sayfa bileşeni aynı kullanıcı verisini paylaşmak istiyorsa
* Navbar’daki kullanıcı bilgisi, profile sayfasında da güncel görünmeli diyorsan
* Biri “like” yaptıysa diğeri bunu fark etmeli

Bu durumda **ortak bir servis** devreye girer.
Servis, aradaki “aracı” (mediator) rolünü üstlenir.

---

## 🧠 3. Subject vs BehaviorSubject

| Özellik                        | Subject                    | BehaviorSubject                   |
| ------------------------------ | -------------------------- | --------------------------------- |
| **İlk değer**                  | Yok                        | Vardır                            |
| **Son değeri hatırlama**       | Hayır                      | Evet                              |
| **Yeni subscriber’a davranış** | Sadece yeni emit’leri alır | Son emit edilen değeri hemen alır |
| **Kullanım örneği**            | Event tabanlı akışlar      | Global state paylaşımı            |

> 🔹 **Best practice:**
> “State tutmak” için → `BehaviorSubject`
> “Olay (event) yaymak” için → `Subject`

---

## 🧱 4. BehaviourSubject Basit Örnek: Ortak Servis Üzerinden Veri Paylaşımı

### **message.service.ts**

```ts
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class MessageService {
  private messageSource = new BehaviorSubject<string>(''); // başlangıç değeri
  currentMessage = this.messageSource.asObservable();

  changeMessage(newMessage: string) {
    this.messageSource.next(newMessage);
  }
}
```

### **sibling-a.component.ts**

```ts
import { Component } from '@angular/core';
import { MessageService } from './message.service';

@Component({
  selector: 'app-sibling-a',
  template: `
    <input [(ngModel)]="msg" placeholder="Mesaj yaz...">
    <button (click)="sendMessage()">Gönder</button>
  `
})
export class SiblingAComponent {
  msg = '';

  constructor(private messageService: MessageService) {}

  sendMessage() {
    this.messageService.changeMessage(this.msg);
  }
}
```

### **sibling-b.component.ts**

```ts
import { Component } from '@angular/core';
import { MessageService } from './message.service';

@Component({
  selector: 'app-sibling-b',
  template: `<p>Son mesaj: {{ message }}</p>`
})
export class SiblingBComponent {
  message = '';

  constructor(private messageService: MessageService) {
    this.messageService.currentMessage.subscribe(msg => this.message = msg);
  }
}
```

---

### Akış Mantığı

1. `SiblingAComponent` servisin `changeMessage()` metodunu çağırır.
2. Servis içindeki `BehaviorSubject` yeni değeri **emit eder**.
3. `SiblingBComponent` bu akışı dinlediği için anında güncellenir.

> 🔹 **Yani:** component’ler birbiriyle doğrudan konuşmaz, ortak servis “mesaj taşıyıcısı” rolünü üstlenir.

---



## 🧱 5. Subject Basit Örnek: Olay (Event) Yayınlama Üzerinden İletişim

### **event.service.ts**

```ts
import { Injectable } from '@angular/core';
import { Subject } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class EventService {
  private notify = new Subject<string>(); // başlangıç değeri yok
  notify$ = this.notify.asObservable();

  sendNotification(message: string) {
    this.notify.next(message); // olay (event) yayını
  }
}
```

---

### **sender.component.ts**

```ts
import { Component } from '@angular/core';
import { EventService } from './event.service';

@Component({
  selector: 'app-sender',
  template: `
    <button (click)="notify()">Bildirim Gönder</button>
  `
})
export class SenderComponent {
  constructor(private eventService: EventService) {}

  notify() {
    const message = 'Yeni bir bildirim var!';
    this.eventService.sendNotification(message);
  }
}
```

---

### **receiver.component.ts**

```ts
import { Component } from '@angular/core';
import { EventService } from './event.service';

@Component({
  selector: 'app-receiver',
  template: `<p>{{ notification }}</p>`
})
export class ReceiverComponent {
  notification = '';

  constructor(private eventService: EventService) {
    this.eventService.notify$.subscribe(msg => {
      this.notification = msg;
    });
  }
}
```

---

### 🧠 Akış Mantığı

1. `SenderComponent`, bir butona tıklanınca `sendNotification()` metodunu çağırır.
2. Servis içindeki `Subject` bir olay (event) **yayınlar** (`next()` ile).
3. `ReceiverComponent`, bu olayı `subscribe()` ederek **dinler** ve tepki verir.

> 🔹 **Yani:** `Subject` olay temelli, anlık veri aktarımında kullanılır —
> geçmişteki değerleri saklamaz, sadece “şimdi olan” olayları yayınlar.



## 🔍 **BehaviorSubject vs Subject Karşılaştırma**

| Özellik                             | **BehaviorSubject**                    | **Subject**                           |
| ----------------------------------- | -------------------------------------- | ------------------------------------- |
| Başlangıç değeri                    | Gereklidir (`new BehaviorSubject('')`) | Gerekli değildir                      |
| Son değeri hatırlar                 | ✅ Evet                                 | ❌ Hayır                               |
| Yeni abone olunca son değeri iletir | ✅ Evet                                 | ❌ Hayır                               |
| Kullanım amacı                      | Global state / paylaşılan veri         | Olay (event) yayını                   |
| Tipik örnek                         | `UserService`, `ThemeService`          | `NotificationService`, `ModalService` |



## ✅ 6. Best Practice Özeti (Subject + BehaviorSubject Ortak)

| Prensip                                            | Açıklama                                                                                                                              |
| -------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| **1. Tek sorumluluk ilkesi**                       | Servis sadece veri veya olay akışını yönetmeli; UI veya iş mantığı component içinde kalmalı.                                          |
| **2. Subject türünü amaca göre seç**               | **State (durum)** paylaşımı için `BehaviorSubject`, **event (olay)** yayını için `Subject` kullan.                                    |
| **3. asObservable() ile dış erişimi sınırla**      | `Subject` veya `BehaviorSubject` sadece servis içinde `next()` ile güncellenmeli; dışarıya yalnızca `Observable` olarak açılmalı.     |
| **4. Subscription yönetimini ihmal etme**          | Her `subscribe()` bir kaynak tüketir. `takeUntil`, `async pipe` veya `Subscription` nesneleriyle temizliği garanti altına al.         |
| **5. Servisi "Singleton" tut** | `@Injectable({ providedIn: 'root' })` ile servis tek örnek (singleton) olarak kullanılmalı; farklı component’lerde aynı akış korunur. |
| **6. Initial state belirle (BehaviorSubject)**     | `BehaviorSubject` daima bir başlangıç değeriyle oluşturulmalı — bu, ilk abone olanların boş veri almamasını sağlar.                   |
| **7. Event akışlarını tamamla (Subject)**          | `Subject` kullandığında `complete()` çağrısını ihmal etme; akış ömrünü doğru yönetmek memory leak’i önler.                            |

---

## 💡 Soyutlama Cümlesi

> **Subject** ve **BehaviorSubject**, Angular’da component’ler arasında **reaktif veri veya olay iletişimi** kurmanın iki temel aracıdır.
>
> * `Subject` → “şu anda gerçekleşen olay” için kullanılır (event-driven).
> * `BehaviorSubject` → “her zaman geçerli olan durumu” taşır (state-driven).
>
> Böylece component’ler, **birbirine doğrudan bağlı olmadan**, tek bir paylaşılan servis aracılığıyla **senkronize, gevşek bağlı (loosely coupled)** ve **ölçeklenebilir** şekilde haberleşir.
















# 2) Gercek Hayat Ornegi


user.service.ts:
```ts
import { Injectable } from "@angular/core";
import { Observable, BehaviorSubject } from "rxjs";

import { JwtService } from "./jwt.service";
import { map, distinctUntilChanged, tap, shareReplay } from "rxjs/operators";
import { HttpClient } from "@angular/common/http";
import { User } from "../user.model";
import { Router } from "@angular/router";

@Injectable({ providedIn: "root" })
export class UserService {
  private currentUserSubject = new BehaviorSubject<User | null>(null);
  public currentUser = this.currentUserSubject
    .asObservable()
    .pipe(distinctUntilChanged());

  public isAuthenticated = this.currentUser.pipe(map((user) => !!user));

  constructor(
    private readonly http: HttpClient,
    private readonly jwtService: JwtService,
    private readonly router: Router,
  ) {}

  login(credentials: {
    email: string;
    password: string;
  }): Observable<{ user: User }> {
    return this.http
      .post<{ user: User }>("/users/login", { user: credentials })
      .pipe(tap(({ user }) => this.setAuth(user)));
  }

  register(credentials: {
    username: string;
    email: string;
    password: string;
  }): Observable<{ user: User }> {
    return this.http
      .post<{ user: User }>("/users", { user: credentials })
      .pipe(tap(({ user }) => this.setAuth(user)));
  }

  logout(): void {
    this.purgeAuth();
    void this.router.navigate(["/"]);
  }

  getCurrentUser(): Observable<{ user: User }> {
    return this.http.get<{ user: User }>("/user").pipe(
      tap({
        next: ({ user }) => this.setAuth(user),
        error: () => this.purgeAuth(),
      }),
      shareReplay(1),
    );
  }

  update(user: Partial<User>): Observable<{ user: User }> {
    return this.http.put<{ user: User }>("/user", { user }).pipe(
      tap(({ user }) => {
        this.currentUserSubject.next(user);
      }),
    );
  }

  setAuth(user: User): void {
    this.jwtService.saveToken(user.token);
    this.currentUserSubject.next(user);
  }

  purgeAuth(): void {
    this.jwtService.destroyToken();
    this.currentUserSubject.next(null);
  }
}
```

user.model.ts:
```ts
export interface User {
  email: string;
  token: string;
  username: string;
  bio: string;
  image: string;
}
```


## 1. Servisteki `BehaviorSubject` Kullanımı

```ts
private currentUserSubject = new BehaviorSubject<User | null>(null);
public currentUser = this.currentUserSubject.asObservable().pipe(distinctUntilChanged());
```

* `currentUserSubject` → içsel (private) subject, veriyi yayınlar.
* `currentUser` → dış dünyaya sadece **Observable** olarak açılır (yani dışarıdan değiştirilemez).
* `distinctUntilChanged()` → aynı kullanıcı tekrar yayınlanmasın diye gereksiz emit’leri engeller.

💡 **Amaç:** Uygulamanın her yerinde *“şu anda giriş yapmış kullanıcı kim?”* sorusuna reactive biçimde yanıt verebilmek.

---

## 2. Reactive Veri Paylaşımı

```ts
this.currentUserSubject.next(user);
```

Bu satır çağrıldığında:

* `currentUser` Observable’ına abone olan tüm component’ler otomatik olarak güncellenir.
* Örneğin Navbar component’i kullanıcı değiştiğinde yeni ismi anında gösterir.

Yani **global bir “shared state”** oluşturulmuş olur.

---

## 3. Ek Yapılar

### `isAuthenticated`

```ts
public isAuthenticated = this.currentUser.pipe(map((user) => !!user));
```

→ Kullanıcı varsa `true`, yoksa `false` yayınlar.
Bu da guard’larda (`canActivate`) veya menü görünürlüklerinde kullanılır.

### `shareReplay(1)`

`getCurrentUser()` içinde kullanılıyor:

```ts
shareReplay(1)
```

Bu sayede HTTP isteği tamamlandıktan sonra sonucu **cache** eder;
aynı isteğe tekrar abone olunduğunda yeniden çağrı yapılmaz.

---















