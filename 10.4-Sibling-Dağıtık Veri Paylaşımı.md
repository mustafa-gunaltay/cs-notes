

# 1)

## ğŸ§© 1. Kavramsal TanÄ±m

**Sibling / DaÄŸÄ±tÄ±k Component iletiÅŸimi**, aynÄ± seviyedeki veya birbirinden baÄŸÄ±msÄ±z componentâ€™lerin **ortak bir servis aracÄ±lÄ±ÄŸÄ±yla veri paylaÅŸmasÄ±dÄ±r.**

> Angular componentâ€™leri birbirinden izole Ã§alÄ±ÅŸÄ±r;
> Bu nedenle, component aÄŸacÄ± iÃ§inde doÄŸrudan baÄŸlantÄ±sÄ± olmayan componentâ€™ler **servis Ã¼zerinden dolaylÄ± (indirect) iletiÅŸim kurar.**

---

## âš™ï¸ 2. Neden Servis KullanÄ±lÄ±r?

`@Input()` ve `@Output()` sadece **ebeveyn â†’ Ã§ocuk** veya **Ã§ocuk â†’ ebeveyn** iletiÅŸimi saÄŸlar.
Ama ÅŸu durumlarda iÅŸe yaramaz:

* Ä°ki farklÄ± sayfa bileÅŸeni aynÄ± kullanÄ±cÄ± verisini paylaÅŸmak istiyorsa
* Navbarâ€™daki kullanÄ±cÄ± bilgisi, profile sayfasÄ±nda da gÃ¼ncel gÃ¶rÃ¼nmeli diyorsan
* Biri â€œlikeâ€ yaptÄ±ysa diÄŸeri bunu fark etmeli

Bu durumda **ortak bir servis** devreye girer.
Servis, aradaki â€œaracÄ±â€ (mediator) rolÃ¼nÃ¼ Ã¼stlenir.

---

## ğŸ§  3. Subject vs BehaviorSubject

| Ã–zellik                        | Subject                    | BehaviorSubject                   |
| ------------------------------ | -------------------------- | --------------------------------- |
| **Ä°lk deÄŸer**                  | Yok                        | VardÄ±r                            |
| **Son deÄŸeri hatÄ±rlama**       | HayÄ±r                      | Evet                              |
| **Yeni subscriberâ€™a davranÄ±ÅŸ** | Sadece yeni emitâ€™leri alÄ±r | Son emit edilen deÄŸeri hemen alÄ±r |
| **KullanÄ±m Ã¶rneÄŸi**            | Event tabanlÄ± akÄ±ÅŸlar      | Global state paylaÅŸÄ±mÄ±            |

> ğŸ”¹ **Best practice:**
> â€œState tutmakâ€ iÃ§in â†’ `BehaviorSubject`
> â€œOlay (event) yaymakâ€ iÃ§in â†’ `Subject`

---

## ğŸ§± 4. BehaviourSubject Basit Ã–rnek: Ortak Servis Ãœzerinden Veri PaylaÅŸÄ±mÄ±

### **message.service.ts**

```ts
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class MessageService {
  private messageSource = new BehaviorSubject<string>(''); // baÅŸlangÄ±Ã§ deÄŸeri
  currentMessage = this.messageSource.asObservable();

  changeMessage(newMessage: string) {
    this.messageSource.next(newMessage);
  }
}
```

### **sibling-a.component.ts**

```ts
import { Component } from '@angular/core';
import { MessageService } from './message.service';

@Component({
  selector: 'app-sibling-a',
  template: `
    <input [(ngModel)]="msg" placeholder="Mesaj yaz...">
    <button (click)="sendMessage()">GÃ¶nder</button>
  `
})
export class SiblingAComponent {
  msg = '';

  constructor(private messageService: MessageService) {}

  sendMessage() {
    this.messageService.changeMessage(this.msg);
  }
}
```

### **sibling-b.component.ts**

```ts
import { Component } from '@angular/core';
import { MessageService } from './message.service';

@Component({
  selector: 'app-sibling-b',
  template: `<p>Son mesaj: {{ message }}</p>`
})
export class SiblingBComponent {
  message = '';

  constructor(private messageService: MessageService) {
    this.messageService.currentMessage.subscribe(msg => this.message = msg);
  }
}
```

---

### AkÄ±ÅŸ MantÄ±ÄŸÄ±

1. `SiblingAComponent` servisin `changeMessage()` metodunu Ã§aÄŸÄ±rÄ±r.
2. Servis iÃ§indeki `BehaviorSubject` yeni deÄŸeri **emit eder**.
3. `SiblingBComponent` bu akÄ±ÅŸÄ± dinlediÄŸi iÃ§in anÄ±nda gÃ¼ncellenir.

> ğŸ”¹ **Yani:** componentâ€™ler birbiriyle doÄŸrudan konuÅŸmaz, ortak servis â€œmesaj taÅŸÄ±yÄ±cÄ±sÄ±â€ rolÃ¼nÃ¼ Ã¼stlenir.

---



## ğŸ§± 5. Subject Basit Ã–rnek: Olay (Event) YayÄ±nlama Ãœzerinden Ä°letiÅŸim

### **event.service.ts**

```ts
import { Injectable } from '@angular/core';
import { Subject } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class EventService {
  private notify = new Subject<string>(); // baÅŸlangÄ±Ã§ deÄŸeri yok
  notify$ = this.notify.asObservable();

  sendNotification(message: string) {
    this.notify.next(message); // olay (event) yayÄ±nÄ±
  }
}
```

---

### **sender.component.ts**

```ts
import { Component } from '@angular/core';
import { EventService } from './event.service';

@Component({
  selector: 'app-sender',
  template: `
    <button (click)="notify()">Bildirim GÃ¶nder</button>
  `
})
export class SenderComponent {
  constructor(private eventService: EventService) {}

  notify() {
    const message = 'Yeni bir bildirim var!';
    this.eventService.sendNotification(message);
  }
}
```

---

### **receiver.component.ts**

```ts
import { Component } from '@angular/core';
import { EventService } from './event.service';

@Component({
  selector: 'app-receiver',
  template: `<p>{{ notification }}</p>`
})
export class ReceiverComponent {
  notification = '';

  constructor(private eventService: EventService) {
    this.eventService.notify$.subscribe(msg => {
      this.notification = msg;
    });
  }
}
```

---

### ğŸ§  AkÄ±ÅŸ MantÄ±ÄŸÄ±

1. `SenderComponent`, bir butona tÄ±klanÄ±nca `sendNotification()` metodunu Ã§aÄŸÄ±rÄ±r.
2. Servis iÃ§indeki `Subject` bir olay (event) **yayÄ±nlar** (`next()` ile).
3. `ReceiverComponent`, bu olayÄ± `subscribe()` ederek **dinler** ve tepki verir.

> ğŸ”¹ **Yani:** `Subject` olay temelli, anlÄ±k veri aktarÄ±mÄ±nda kullanÄ±lÄ±r â€”
> geÃ§miÅŸteki deÄŸerleri saklamaz, sadece â€œÅŸimdi olanâ€ olaylarÄ± yayÄ±nlar.



## ğŸ” **BehaviorSubject vs Subject KarÅŸÄ±laÅŸtÄ±rma**

| Ã–zellik                             | **BehaviorSubject**                    | **Subject**                           |
| ----------------------------------- | -------------------------------------- | ------------------------------------- |
| BaÅŸlangÄ±Ã§ deÄŸeri                    | Gereklidir (`new BehaviorSubject('')`) | Gerekli deÄŸildir                      |
| Son deÄŸeri hatÄ±rlar                 | âœ… Evet                                 | âŒ HayÄ±r                               |
| Yeni abone olunca son deÄŸeri iletir | âœ… Evet                                 | âŒ HayÄ±r                               |
| KullanÄ±m amacÄ±                      | Global state / paylaÅŸÄ±lan veri         | Olay (event) yayÄ±nÄ±                   |
| Tipik Ã¶rnek                         | `UserService`, `ThemeService`          | `NotificationService`, `ModalService` |



## âœ… 6. Best Practice Ã–zeti (Subject + BehaviorSubject Ortak)

| Prensip                                            | AÃ§Ä±klama                                                                                                                              |
| -------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| **1. Tek sorumluluk ilkesi**                       | Servis sadece veri veya olay akÄ±ÅŸÄ±nÄ± yÃ¶netmeli; UI veya iÅŸ mantÄ±ÄŸÄ± component iÃ§inde kalmalÄ±.                                          |
| **2. Subject tÃ¼rÃ¼nÃ¼ amaca gÃ¶re seÃ§**               | **State (durum)** paylaÅŸÄ±mÄ± iÃ§in `BehaviorSubject`, **event (olay)** yayÄ±nÄ± iÃ§in `Subject` kullan.                                    |
| **3. asObservable() ile dÄ±ÅŸ eriÅŸimi sÄ±nÄ±rla**      | `Subject` veya `BehaviorSubject` sadece servis iÃ§inde `next()` ile gÃ¼ncellenmeli; dÄ±ÅŸarÄ±ya yalnÄ±zca `Observable` olarak aÃ§Ä±lmalÄ±.     |
| **4. Subscription yÃ¶netimini ihmal etme**          | Her `subscribe()` bir kaynak tÃ¼ketir. `takeUntil`, `async pipe` veya `Subscription` nesneleriyle temizliÄŸi garanti altÄ±na al.         |
| **5. Servisi "Singleton" tut** | `@Injectable({ providedIn: 'root' })` ile servis tek Ã¶rnek (singleton) olarak kullanÄ±lmalÄ±; farklÄ± componentâ€™lerde aynÄ± akÄ±ÅŸ korunur. |
| **6. Initial state belirle (BehaviorSubject)**     | `BehaviorSubject` daima bir baÅŸlangÄ±Ã§ deÄŸeriyle oluÅŸturulmalÄ± â€” bu, ilk abone olanlarÄ±n boÅŸ veri almamasÄ±nÄ± saÄŸlar.                   |
| **7. Event akÄ±ÅŸlarÄ±nÄ± tamamla (Subject)**          | `Subject` kullandÄ±ÄŸÄ±nda `complete()` Ã§aÄŸrÄ±sÄ±nÄ± ihmal etme; akÄ±ÅŸ Ã¶mrÃ¼nÃ¼ doÄŸru yÃ¶netmek memory leakâ€™i Ã¶nler.                            |

---

## ğŸ’¡ Soyutlama CÃ¼mlesi

> **Subject** ve **BehaviorSubject**, Angularâ€™da componentâ€™ler arasÄ±nda **reaktif veri veya olay iletiÅŸimi** kurmanÄ±n iki temel aracÄ±dÄ±r.
>
> * `Subject` â†’ â€œÅŸu anda gerÃ§ekleÅŸen olayâ€ iÃ§in kullanÄ±lÄ±r (event-driven).
> * `BehaviorSubject` â†’ â€œher zaman geÃ§erli olan durumuâ€ taÅŸÄ±r (state-driven).
>
> BÃ¶ylece componentâ€™ler, **birbirine doÄŸrudan baÄŸlÄ± olmadan**, tek bir paylaÅŸÄ±lan servis aracÄ±lÄ±ÄŸÄ±yla **senkronize, gevÅŸek baÄŸlÄ± (loosely coupled)** ve **Ã¶lÃ§eklenebilir** ÅŸekilde haberleÅŸir.
















# 2) Gercek Hayat Ornegi


user.service.ts:
```ts
import { Injectable } from "@angular/core";
import { Observable, BehaviorSubject } from "rxjs";

import { JwtService } from "./jwt.service";
import { map, distinctUntilChanged, tap, shareReplay } from "rxjs/operators";
import { HttpClient } from "@angular/common/http";
import { User } from "../user.model";
import { Router } from "@angular/router";

@Injectable({ providedIn: "root" })
export class UserService {
  private currentUserSubject = new BehaviorSubject<User | null>(null);
  public currentUser = this.currentUserSubject
    .asObservable()
    .pipe(distinctUntilChanged());

  public isAuthenticated = this.currentUser.pipe(map((user) => !!user));

  constructor(
    private readonly http: HttpClient,
    private readonly jwtService: JwtService,
    private readonly router: Router,
  ) {}

  login(credentials: {
    email: string;
    password: string;
  }): Observable<{ user: User }> {
    return this.http
      .post<{ user: User }>("/users/login", { user: credentials })
      .pipe(tap(({ user }) => this.setAuth(user)));
  }

  register(credentials: {
    username: string;
    email: string;
    password: string;
  }): Observable<{ user: User }> {
    return this.http
      .post<{ user: User }>("/users", { user: credentials })
      .pipe(tap(({ user }) => this.setAuth(user)));
  }

  logout(): void {
    this.purgeAuth();
    void this.router.navigate(["/"]);
  }

  getCurrentUser(): Observable<{ user: User }> {
    return this.http.get<{ user: User }>("/user").pipe(
      tap({
        next: ({ user }) => this.setAuth(user),
        error: () => this.purgeAuth(),
      }),
      shareReplay(1),
    );
  }

  update(user: Partial<User>): Observable<{ user: User }> {
    return this.http.put<{ user: User }>("/user", { user }).pipe(
      tap(({ user }) => {
        this.currentUserSubject.next(user);
      }),
    );
  }

  setAuth(user: User): void {
    this.jwtService.saveToken(user.token);
    this.currentUserSubject.next(user);
  }

  purgeAuth(): void {
    this.jwtService.destroyToken();
    this.currentUserSubject.next(null);
  }
}
```

user.model.ts:
```ts
export interface User {
  email: string;
  token: string;
  username: string;
  bio: string;
  image: string;
}
```


## 1. Servisteki `BehaviorSubject` KullanÄ±mÄ±

```ts
private currentUserSubject = new BehaviorSubject<User | null>(null);
public currentUser = this.currentUserSubject.asObservable().pipe(distinctUntilChanged());
```

* `currentUserSubject` â†’ iÃ§sel (private) subject, veriyi yayÄ±nlar.
* `currentUser` â†’ dÄ±ÅŸ dÃ¼nyaya sadece **Observable** olarak aÃ§Ä±lÄ±r (yani dÄ±ÅŸarÄ±dan deÄŸiÅŸtirilemez).
* `distinctUntilChanged()` â†’ aynÄ± kullanÄ±cÄ± tekrar yayÄ±nlanmasÄ±n diye gereksiz emitâ€™leri engeller.

ğŸ’¡ **AmaÃ§:** UygulamanÄ±n her yerinde *â€œÅŸu anda giriÅŸ yapmÄ±ÅŸ kullanÄ±cÄ± kim?â€* sorusuna reactive biÃ§imde yanÄ±t verebilmek.

---

## 2. Reactive Veri PaylaÅŸÄ±mÄ±

```ts
this.currentUserSubject.next(user);
```

Bu satÄ±r Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda:

* `currentUser` Observableâ€™Ä±na abone olan tÃ¼m componentâ€™ler otomatik olarak gÃ¼ncellenir.
* Ã–rneÄŸin Navbar componentâ€™i kullanÄ±cÄ± deÄŸiÅŸtiÄŸinde yeni ismi anÄ±nda gÃ¶sterir.

Yani **global bir â€œshared stateâ€** oluÅŸturulmuÅŸ olur.

---

## 3. Ek YapÄ±lar

### `isAuthenticated`

```ts
public isAuthenticated = this.currentUser.pipe(map((user) => !!user));
```

â†’ KullanÄ±cÄ± varsa `true`, yoksa `false` yayÄ±nlar.
Bu da guardâ€™larda (`canActivate`) veya menÃ¼ gÃ¶rÃ¼nÃ¼rlÃ¼klerinde kullanÄ±lÄ±r.

### `shareReplay(1)`

`getCurrentUser()` iÃ§inde kullanÄ±lÄ±yor:

```ts
shareReplay(1)
```

Bu sayede HTTP isteÄŸi tamamlandÄ±ktan sonra sonucu **cache** eder;
aynÄ± isteÄŸe tekrar abone olunduÄŸunda yeniden Ã§aÄŸrÄ± yapÄ±lmaz.

---















