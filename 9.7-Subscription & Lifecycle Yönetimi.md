

# 1) 


## ⚙️ **7️⃣ Subscription & Lifecycle Yönetimi**

### 📘 1. Kavramsal Tanım

Her `Observable` sadece **potansiyel bir akıştır** — çalışmaz, ta ki biri ona **abone (`subscribe`) olana kadar**.

* `subscribe()` → Akışı **başlatır**, veri üretimi burada olur.
* `unsubscribe()` → Akışı **durdurur**, kaynaklar serbest bırakılır.

💡 **Soyut tanım:**

> “Veri dinlemeye başlamak ve sonlandırmak senin sorumluluğundadır.”

---

### ⚡ 2. Neden Önemlidir?

Reaktif sistemlerde:

* Her `subscribe()` yeni bir **bağlantı (connection)** açar.
* Eğer `unsubscribe()` yapılmazsa, akış dinlemeye devam eder → **memory leak (bellek sızıntısı)** oluşur.

Özellikle Angular bileşenlerinde (component lifecycle), component yok olsa bile aktif stream’ler çalışmaya devam edebilir.
Bu, hem performans hem de veri tutarlılığı açısından risklidir.

---

### 💻 3. Basit Örnek — Manuel `unsubscribe()`

```ts
import { interval, Subscription } from 'rxjs';

export class TimerComponent {
  private timerSub!: Subscription;

  startTimer() {
    this.timerSub = interval(1000).subscribe(val => console.log('Saniye:', val));
  }

  stopTimer() {
    this.timerSub.unsubscribe();
    console.log('Zamanlayıcı durduruldu.');
  }
}
```

🧠 **Mantık:**

* `interval()` her saniye yeni bir değer `emit` eder.
* `subscribe()` dinlemeye başlar.
* `unsubscribe()` akışı durdurur.

---

### 🧩 4. Angular’da Lifecycle ile Yönetim (Best Practice)

Angular’da `ngOnDestroy()` lifecycle metodu **component yok olurken** çağrılır.
Burada `unsubscribe()` çağırmak gerekir.

```ts
import { interval, Subscription } from 'rxjs';

export class TimerComponent implements OnDestroy {
  private timerSub = new Subscription();

  ngOnInit() {
    this.timerSub = interval(1000).subscribe(v => console.log('Tick:', v));
  }

  ngOnDestroy() {
    this.timerSub.unsubscribe();
  }
}
```

---

### 🧱 5. Daha Modern Yaklaşım — `takeUntil()` / `takeUntilDestroyed()`

Angular 16+ sürümünde gelen **`takeUntilDestroyed()`** operatörü, manuel `unsubscribe()` ihtiyacını ortadan kaldırır.

```ts
import { interval } from 'rxjs';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { DestroyRef, inject } from '@angular/core';

export class TimerComponent {
  destroyRef = inject(DestroyRef);

  ngOnInit() {
    interval(1000)
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe(v => console.log('Tick:', v));
  }
}
```

🧠 **Avantaj:**

* Component yok olduğunda Angular otomatik olarak `unsubscribe` eder.
* Daha az kod, daha az hata riski.

---

### ✅ 6. Best Practice

| Prensip                                                           | Açıklama                                                      |
| ----------------------------------------------------------------- | ------------------------------------------------------------- |
| **1. Her `subscribe` bir bağlantıdır**                            | Gerekmedikçe çoğaltma, `async pipe` veya `takeUntil` kullan.  |
| **2. Component yok olurken `unsubscribe()` yap**                  | Aksi halde memory leak oluşur.                                |
| **3. Angular 16+ kullanıyorsan `takeUntilDestroyed()` tercih et** | Manuel temizlik gerekmez.                                     |
| **4. Service tarafında uzun ömürlü stream’leri dikkatli tasarla** | Global akışlar (örn. user state) component’lerle karışmamalı. |

---

### 💡 Soyutlama Cümlesi

> Her reaktif akış bir “abonelik”tir; onu başlatmak senin elindedir, durdurmak da öyle.
> Kodun “tepki veren” doğası ancak lifecycle yönetimiyle kontrol altında tutulur.

---


