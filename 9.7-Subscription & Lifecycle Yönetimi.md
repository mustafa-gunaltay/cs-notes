

# 1) 


## âš™ï¸ **7ï¸âƒ£ Subscription & Lifecycle YÃ¶netimi**

### ğŸ“˜ 1. Kavramsal TanÄ±m

Her `Observable` sadece **potansiyel bir akÄ±ÅŸtÄ±r** â€” Ã§alÄ±ÅŸmaz, ta ki biri ona **abone (`subscribe`) olana kadar**.

* `subscribe()` â†’ AkÄ±ÅŸÄ± **baÅŸlatÄ±r**, veri Ã¼retimi burada olur.
* `unsubscribe()` â†’ AkÄ±ÅŸÄ± **durdurur**, kaynaklar serbest bÄ±rakÄ±lÄ±r.

ğŸ’¡ **Soyut tanÄ±m:**

> â€œVeri dinlemeye baÅŸlamak ve sonlandÄ±rmak senin sorumluluÄŸundadÄ±r.â€

---

### âš¡ 2. Neden Ã–nemlidir?

Reaktif sistemlerde:

* Her `subscribe()` yeni bir **baÄŸlantÄ± (connection)** aÃ§ar.
* EÄŸer `unsubscribe()` yapÄ±lmazsa, akÄ±ÅŸ dinlemeye devam eder â†’ **memory leak (bellek sÄ±zÄ±ntÄ±sÄ±)** oluÅŸur.

Ã–zellikle Angular bileÅŸenlerinde (component lifecycle), component yok olsa bile aktif streamâ€™ler Ã§alÄ±ÅŸmaya devam edebilir.
Bu, hem performans hem de veri tutarlÄ±lÄ±ÄŸÄ± aÃ§Ä±sÄ±ndan risklidir.

---

### ğŸ’» 3. Basit Ã–rnek â€” Manuel `unsubscribe()`

```ts
import { interval, Subscription } from 'rxjs';

export class TimerComponent {
  private timerSub!: Subscription;

  startTimer() {
    this.timerSub = interval(1000).subscribe(val => console.log('Saniye:', val));
  }

  stopTimer() {
    this.timerSub.unsubscribe();
    console.log('ZamanlayÄ±cÄ± durduruldu.');
  }
}
```

ğŸ§  **MantÄ±k:**

* `interval()` her saniye yeni bir deÄŸer `emit` eder.
* `subscribe()` dinlemeye baÅŸlar.
* `unsubscribe()` akÄ±ÅŸÄ± durdurur.

---

### ğŸ§© 4. Angularâ€™da Lifecycle ile YÃ¶netim (Best Practice)

Angularâ€™da `ngOnDestroy()` lifecycle metodu **component yok olurken** Ã§aÄŸrÄ±lÄ±r.
Burada `unsubscribe()` Ã§aÄŸÄ±rmak gerekir.

```ts
import { interval, Subscription } from 'rxjs';

export class TimerComponent implements OnDestroy {
  private timerSub = new Subscription();

  ngOnInit() {
    this.timerSub = interval(1000).subscribe(v => console.log('Tick:', v));
  }

  ngOnDestroy() {
    this.timerSub.unsubscribe();
  }
}
```

---

### ğŸ§± 5. Daha Modern YaklaÅŸÄ±m â€” `takeUntil()` / `takeUntilDestroyed()`

Angular 16+ sÃ¼rÃ¼mÃ¼nde gelen **`takeUntilDestroyed()`** operatÃ¶rÃ¼, manuel `unsubscribe()` ihtiyacÄ±nÄ± ortadan kaldÄ±rÄ±r.

```ts
import { interval } from 'rxjs';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { DestroyRef, inject } from '@angular/core';

export class TimerComponent {
  destroyRef = inject(DestroyRef);

  ngOnInit() {
    interval(1000)
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe(v => console.log('Tick:', v));
  }
}
```

ğŸ§  **Avantaj:**

* Component yok olduÄŸunda Angular otomatik olarak `unsubscribe` eder.
* Daha az kod, daha az hata riski.

---

### âœ… 6. Best Practice

| Prensip                                                           | AÃ§Ä±klama                                                      |
| ----------------------------------------------------------------- | ------------------------------------------------------------- |
| **1. Her `subscribe` bir baÄŸlantÄ±dÄ±r**                            | GerekmedikÃ§e Ã§oÄŸaltma, `async pipe` veya `takeUntil` kullan.  |
| **2. Component yok olurken `unsubscribe()` yap**                  | Aksi halde memory leak oluÅŸur.                                |
| **3. Angular 16+ kullanÄ±yorsan `takeUntilDestroyed()` tercih et** | Manuel temizlik gerekmez.                                     |
| **4. Service tarafÄ±nda uzun Ã¶mÃ¼rlÃ¼ streamâ€™leri dikkatli tasarla** | Global akÄ±ÅŸlar (Ã¶rn. user state) componentâ€™lerle karÄ±ÅŸmamalÄ±. |

---

### ğŸ’¡ Soyutlama CÃ¼mlesi

> Her reaktif akÄ±ÅŸ bir â€œabonelikâ€tir; onu baÅŸlatmak senin elindedir, durdurmak da Ã¶yle.
> Kodun â€œtepki verenâ€ doÄŸasÄ± ancak lifecycle yÃ¶netimiyle kontrol altÄ±nda tutulur.

---


