

# 1) 


## ğŸ§© **5ï¸âƒ£ combineLatest ve Ã‡oklu AkÄ±ÅŸ YÃ¶netimi**

### ğŸ“˜ 1. Kavramsal TanÄ±m

GerÃ§ek bir uygulamada genelde **birden fazla veri kaynaÄŸÄ± (stream)** vardÄ±r:
Ã¶rneÄŸin,

* bir **kullanÄ±cÄ±nÄ±n seÃ§imleri (dropdown, checkbox, input)**
* bir **API yanÄ±tÄ± (HTTP Observable)**
* veya bir **timer / sensÃ¶r akÄ±ÅŸÄ±**

Bu akÄ±ÅŸlar **baÄŸÄ±msÄ±z** ama **birbiriyle iliÅŸkili** olabilir.
Ä°ÅŸte `combineLatest()` gibi operatÃ¶rler, bu birden fazla akÄ±ÅŸÄ± **senkronize edip tek bir birleÅŸik akÄ±ÅŸ** haline getirir.

> ğŸ’¡ **Soyut tanÄ±m:**
> â€œBirden fazla veri kaynaÄŸÄ±nÄ± aynÄ± zaman ekseninde hizala.â€

---

### âš™ï¸ 2. Temel KullanÄ±m

```ts
import { combineLatest, of } from 'rxjs';
import { map } from 'rxjs/operators';

const name$ = of('Mustafa');
const age$ = of(22);

combineLatest([name$, age$])
  .pipe(map(([name, age]) => `${name} is ${age} years old`))
  .subscribe(console.log);
```

ğŸ§  **AÃ§Ä±klama:**

* Her Observable (`name$`, `age$`) bir deÄŸer *emit* eder.
* `combineLatest()` â†’ her biri yeni deÄŸer Ã¼rettiÄŸinde, **tÃ¼m son deÄŸerleri alÄ±r** ve bir **dizi olarak** dÃ¶ner.
* Bu dizi (`[name, age]`) `map()` ile birleÅŸtirilip tek bir anlamlÄ± Ã§Ä±ktÄ± haline gelir.

ğŸ“¤ **Ã‡Ä±ktÄ±:**

```
Mustafa is 22 years old
```

---

### ğŸ”„ 3. Reaktif AkÄ±ÅŸ MantÄ±ÄŸÄ±

```
name$   :   Mustafa â”€â”€â”€â”€â”€â”€â”€â”€â†’
age$    :   22 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
combine :   [Mustafa, 22] â”€â”€â†’ map() â†’ "Mustafa is 22 years old"
```

> Yani, her akÄ±ÅŸ kendi zamanÄ±nda Ã§alÄ±ÅŸsa bile,
> `combineLatest()` onlarÄ± **en son deÄŸerleriyle** senkronize eder.

---

### âš¡ 4. GerÃ§ek Hayat Ã–rneÄŸi (Angular)

```ts
combineLatest([
  this.selectedCategory$,
  this.categoryService.getProducts()
]).pipe(
  map(([category, products]) =>
    products.filter(p => p.categoryId === category.id)
  )
).subscribe(filtered => this.displayedProducts = filtered);
```

ğŸ§  **Ne oluyor:**

* KullanÄ±cÄ± kategori seÃ§tiÄŸinde `selectedCategory$` yeni bir deÄŸer *emit* ediyor.
* APIâ€™den Ã¼rÃ¼n listesi geldiÄŸinde `getProducts()` yeni bir deÄŸer *emit* ediyor.
* `combineLatest()` bu iki akÄ±ÅŸÄ± **senkronize ediyor** â†’
  yeni kategori seÃ§ildiÄŸinde veya Ã¼rÃ¼n listesi yenilendiÄŸinde gÃ¶rÃ¼nÃ¼m (UI) reaktif olarak gÃ¼ncelleniyor.

---

### âœ… 5. Best Practiceâ€™ler

| Prensip                                                                                | AÃ§Ä±klama                                                                                   |
| -------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| **1. combineLatest yalnÄ±zca her Observable en az bir kez emit ettikten sonra Ã§alÄ±ÅŸÄ±r** | Yani baÅŸlangÄ±Ã§ta hiÃ§bir deÄŸer yoksa tetiklenmez.                                           |
| **2. `map()` veya `switchMap()` ile birlikte kullan**                                  | BÃ¶ylece veriyi dÃ¶nÃ¼ÅŸtÃ¼rÃ¼p UIâ€™a uygun hale getirebilirsin.                                  |
| **3. `startWith()` ekleyerek ilk deÄŸeri garanti et**                                   | BoÅŸ durumlarda UIâ€™in donmamasÄ± iÃ§in.                                                       |
| **4. Tek sorumluluk**                                                                  | combineLatest yalnÄ±zca â€œeÅŸzamanlamaâ€ iÃ§in kullanÄ±lmalÄ±, dÃ¶nÃ¼ÅŸÃ¼m iÅŸi `map()`â€™e bÄ±rakÄ±lmalÄ±. |

---

### ğŸ’¡ Soyutlama CÃ¼mlesi

> â€œ`combineLatest()` reaktif sistemin senkronizasyon katmanÄ±dÄ±r.
> Birden fazla baÄŸÄ±msÄ±z akÄ±ÅŸÄ± aynÄ± anda izler,
> ve her biri yeni deÄŸer Ã¼rettiÄŸinde birleÅŸik bir tepki (reaksiyon) oluÅŸturur.â€

---











# 2) Gercek Hayat Ornegi

```ts
export default class ArticleComponent implements OnInit {
  article!: Article;
  currentUser!: User | null;
  comments: Comment[] = [];
  canModify: boolean = false;

  commentControl = new FormControl<string>("", { nonNullable: true });
  commentFormErrors: Errors | null = null;

  isSubmitting = false;
  isDeleting = false;
  destroyRef = inject(DestroyRef);

  constructor(
    private readonly route: ActivatedRoute,
    private readonly articleService: ArticlesService,
    private readonly commentsService: CommentsService,
    private readonly router: Router,
    private readonly userService: UserService,
  ) {}

  ngOnInit(): void {
    const slug = this.route.snapshot.params["slug"];
    combineLatest([
      this.articleService.get(slug),
      this.commentsService.getAll(slug),
      this.userService.currentUser,
    ])
      .pipe(
        catchError((err) => {
          void this.router.navigate(["/"]);
          return throwError(() => err);
        }),
        takeUntilDestroyed(this.destroyRef),
      )
      .subscribe(([article, comments, currentUser]) => {
        this.article = article;
        this.comments = comments;
        this.currentUser = currentUser;
        this.canModify = currentUser?.username === article.author.username;
      });
  }

...
}
```

- Gercek hayattaki bir makale sayfasi -> makale verisi, makale yorumlarÄ± ve mevcut kullanÄ±cÄ± bir butundur. Dolayisiyla bunlardan herhangi biri degistiginde hepsinin ayni anda guncellenmesi ( birbirine bagli sekilde handle edilmesi) gerekir. 
- Ornegin makale (slug) deÄŸiÅŸirse, makale verisi ve o makalenin yorumlarÄ± yeniden yÃ¼klenmelidir. 

