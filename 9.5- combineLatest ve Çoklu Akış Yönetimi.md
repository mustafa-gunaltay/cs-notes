

# 1) 


## 🧩 **5️⃣ combineLatest ve Çoklu Akış Yönetimi**

### 📘 1. Kavramsal Tanım

Gerçek bir uygulamada genelde **birden fazla veri kaynağı (stream)** vardır:
örneğin,

* bir **kullanıcının seçimleri (dropdown, checkbox, input)**
* bir **API yanıtı (HTTP Observable)**
* veya bir **timer / sensör akışı**

Bu akışlar **bağımsız** ama **birbiriyle ilişkili** olabilir.
İşte `combineLatest()` gibi operatörler, bu birden fazla akışı **senkronize edip tek bir birleşik akış** haline getirir.

> 💡 **Soyut tanım:**
> “Birden fazla veri kaynağını aynı zaman ekseninde hizala.”

---

### ⚙️ 2. Temel Kullanım

```ts
import { combineLatest, of } from 'rxjs';
import { map } from 'rxjs/operators';

const name$ = of('Mustafa');
const age$ = of(22);

combineLatest([name$, age$])
  .pipe(map(([name, age]) => `${name} is ${age} years old`))
  .subscribe(console.log);
```

🧠 **Açıklama:**

* Her Observable (`name$`, `age$`) bir değer *emit* eder.
* `combineLatest()` → her biri yeni değer ürettiğinde, **tüm son değerleri alır** ve bir **dizi olarak** döner.
* Bu dizi (`[name, age]`) `map()` ile birleştirilip tek bir anlamlı çıktı haline gelir.

📤 **Çıktı:**

```
Mustafa is 22 years old
```

---

### 🔄 3. Reaktif Akış Mantığı

```
name$   :   Mustafa ────────→
age$    :   22 ─────────────→
combine :   [Mustafa, 22] ──→ map() → "Mustafa is 22 years old"
```

> Yani, her akış kendi zamanında çalışsa bile,
> `combineLatest()` onları **en son değerleriyle** senkronize eder.

---

### ⚡ 4. Gerçek Hayat Örneği (Angular)

```ts
combineLatest([
  this.selectedCategory$,
  this.categoryService.getProducts()
]).pipe(
  map(([category, products]) =>
    products.filter(p => p.categoryId === category.id)
  )
).subscribe(filtered => this.displayedProducts = filtered);
```

🧠 **Ne oluyor:**

* Kullanıcı kategori seçtiğinde `selectedCategory$` yeni bir değer *emit* ediyor.
* API’den ürün listesi geldiğinde `getProducts()` yeni bir değer *emit* ediyor.
* `combineLatest()` bu iki akışı **senkronize ediyor** →
  yeni kategori seçildiğinde veya ürün listesi yenilendiğinde görünüm (UI) reaktif olarak güncelleniyor.

---

### ✅ 5. Best Practice’ler

| Prensip                                                                                | Açıklama                                                                                   |
| -------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| **1. combineLatest yalnızca her Observable en az bir kez emit ettikten sonra çalışır** | Yani başlangıçta hiçbir değer yoksa tetiklenmez.                                           |
| **2. `map()` veya `switchMap()` ile birlikte kullan**                                  | Böylece veriyi dönüştürüp UI’a uygun hale getirebilirsin.                                  |
| **3. `startWith()` ekleyerek ilk değeri garanti et**                                   | Boş durumlarda UI’in donmaması için.                                                       |
| **4. Tek sorumluluk**                                                                  | combineLatest yalnızca “eşzamanlama” için kullanılmalı, dönüşüm işi `map()`’e bırakılmalı. |

---

### 💡 Soyutlama Cümlesi

> “`combineLatest()` reaktif sistemin senkronizasyon katmanıdır.
> Birden fazla bağımsız akışı aynı anda izler,
> ve her biri yeni değer ürettiğinde birleşik bir tepki (reaksiyon) oluşturur.”

---











# 2) Gercek Hayat Ornegi

```ts
export default class ArticleComponent implements OnInit {
  article!: Article;
  currentUser!: User | null;
  comments: Comment[] = [];
  canModify: boolean = false;

  commentControl = new FormControl<string>("", { nonNullable: true });
  commentFormErrors: Errors | null = null;

  isSubmitting = false;
  isDeleting = false;
  destroyRef = inject(DestroyRef);

  constructor(
    private readonly route: ActivatedRoute,
    private readonly articleService: ArticlesService,
    private readonly commentsService: CommentsService,
    private readonly router: Router,
    private readonly userService: UserService,
  ) {}

  ngOnInit(): void {
    const slug = this.route.snapshot.params["slug"];
    combineLatest([
      this.articleService.get(slug),
      this.commentsService.getAll(slug),
      this.userService.currentUser,
    ])
      .pipe(
        catchError((err) => {
          void this.router.navigate(["/"]);
          return throwError(() => err);
        }),
        takeUntilDestroyed(this.destroyRef),
      )
      .subscribe(([article, comments, currentUser]) => {
        this.article = article;
        this.comments = comments;
        this.currentUser = currentUser;
        this.canModify = currentUser?.username === article.author.username;
      });
  }

...
}
```

- Gercek hayattaki bir makale sayfasi -> makale verisi, makale yorumları ve mevcut kullanıcı bir butundur. Dolayisiyla bunlardan herhangi biri degistiginde hepsinin ayni anda guncellenmesi ( birbirine bagli sekilde handle edilmesi) gerekir. 
- Ornegin makale (slug) değişirse, makale verisi ve o makalenin yorumları yeniden yüklenmelidir. 

