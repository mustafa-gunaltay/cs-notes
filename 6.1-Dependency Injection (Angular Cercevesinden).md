
# 1) Angular cercevesinden Dependency Injection (DI) nedir, hangi problemi cozer, nasil kullanilir ?



## ğŸ§© 1. Angularâ€™da Dependency Injection (DI) Nedir?

ğŸ“˜ **TanÄ±m:**
**Dependency Injection**, bir classâ€™Ä±n (Ã¶rneÄŸin bir componentâ€™in) ihtiyaÃ§ duyduÄŸu baÄŸÄ±mlÄ±lÄ±klarÄ±n (**service, helper, repository**) **otomatik olarak Angular tarafÄ±ndan saÄŸlanmasÄ± (inject edilmesi)** mekanizmasÄ±dÄ±r.

> BaÅŸka bir deyiÅŸle:
> â€œNesneleri kendin oluÅŸturmak yerine, Angularâ€™Ä±n sana vermesini istersin.â€

---

## ğŸ¯ 2. Hangi Problemi Ã‡Ã¶zer?

Normalde bir component, bir servisi **`new`** ile Ã¼retirse:

* Component ile service **sÄ±kÄ± baÄŸlÄ± (tightly coupled)** olur.
* Test etmek zorlaÅŸÄ±r.
* Kod tekrar kullanÄ±labilirliÄŸini kaybeder.

```ts
// KÃ¶tÃ¼ Ã¶rnek â€” manuel baÄŸÄ±mlÄ±lÄ±k
export class AppComponent {
  service = new LoggerService();
}
```

Bunun yerine Angular DI kullanÄ±r:

```ts
// Ä°yi Ã¶rnek â€” gevÅŸek baÄŸlÄ±lÄ±k (loose coupling)
export class AppComponent {
  constructor(private logger: LoggerService) {}
}
```

ğŸ’¡ **Ã–zet:**

> DI, **oluÅŸturma (construction)** sorumluluÄŸunu Angularâ€™a devrederek
> bileÅŸenleri birbirinden **baÄŸÄ±msÄ±z ve test edilebilir** hale getirir.

---

## âš™ï¸ 3. Angularâ€™da DI NasÄ±l Ã‡alÄ±ÅŸÄ±r?

Angular, bir **Injector Tree (BaÄŸÄ±mlÄ±lÄ±k AÄŸacÄ±)** oluÅŸturur.
Bu aÄŸaÃ§:

* Her componentâ€™in kendi injectorâ€™una sahip olmasÄ±nÄ± saÄŸlar,
* Angularâ€™Ä±n baÄŸÄ±mlÄ±lÄ±klarÄ± yukarÄ±dan aÅŸaÄŸÄ±ya Ã§Ã¶zmesine olanak verir.

**Temel Ã§alÄ±ÅŸma sÄ±rasÄ±:**

1. Component `constructor()` iÃ§inde bir baÄŸÄ±mlÄ±lÄ±k ister (`private userService: UserService`)
2. Angular bu servisi arar:

   * Ã–nce componentâ€™in injectorâ€™unda,
   * Sonra parent moduleâ€™lerde,
   * En son `root injector`â€™da (global seviyede).
3. BulduÄŸunda otomatik olarak **inject eder**.

---

## ğŸ§± 4. Ã–rnek KullanÄ±m

**logger.service.ts**

```ts
import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class LoggerService {
  log(message: string) {
    console.log('Log:', message);
  }
}
```

**app.component.ts**

```ts
import { Component } from '@angular/core';
import { LoggerService } from './logger.service';

@Component({
  selector: 'app-root',
  template: `<button (click)="sendLog()">Logla</button>`
})
export class AppComponent {
  constructor(private logger: LoggerService) {}

  sendLog() {
    this.logger.log('KullanÄ±cÄ± butona tÄ±kladÄ±!');
  }
}
```

ğŸŸ¢ **AÃ§Ä±klama:**

* `@Injectable({ providedIn: 'root' })` â†’ Angularâ€™a bu servisi global olarak yÃ¶netmesini sÃ¶yler.
* Component `LoggerService` ister â†’ Angular otomatik olarak aynÄ± instanceâ€™Ä± verir.
* BÃ¶ylece uygulama boyunca tek (singleton) bir `LoggerService` kullanÄ±lÄ±r.

---


## 5. ğŸ†• Angular 14+ ile Yeni SÃ¶z Dizimi

```ts
private readonly route = inject(ActivatedRoute);
```

* `inject()` ifadesi, klasik `constructor(private route: ActivatedRoute) {}` sÃ¶zdiziminin **yeni, kÄ±saltÄ±lmÄ±ÅŸ halidir** (Angular 14+).
* AynÄ± DI sistemini kullanÄ±r, sadece **daha sade bir syntax** sunar.
* Bu sayede component constructorâ€™larÄ± sadeleÅŸir ve **Dependency Injection artÄ±k fonksiyonel seviyede de** kullanÄ±labilir.


## ğŸ§  6. Best Practiceâ€™ler

| Prensip                               | AÃ§Ä±klama                                                                                         |
| ------------------------------------- | ------------------------------------------------------------------------------------------------ |
| **1. â€œnewâ€ kullanma**                 | Angular baÄŸÄ±mlÄ±lÄ±klarÄ± kendisi oluÅŸturmalÄ±. `new` operatÃ¶rÃ¼nÃ¼ asla kullanma.                     |
| **2. Injectable kullan**              | Servisleri her zaman `@Injectable()` decoratorâ€™Ä± ile iÅŸaretle.                                   |
| **3. â€œprovidedIn: 'root'â€ tercih et** | KÃ¼Ã§Ã¼k uygulamalarda global injection idealdir; modÃ¼l bazÄ±nda gerekirse scope deÄŸiÅŸtir.           |
| **4. Single Responsibility**          | Her service yalnÄ±zca tek iÅŸlevi kapsasÄ±n (Ã¶r. `UserService`, `AuthService`).                     |
| **5. Test Edilebilirlik**             | DI sayesinde mock veya fake servisler enjekte edebilirsin â€” unit testlerde bÃ¼yÃ¼k avantaj saÄŸlar. |

---

## ğŸ’¡ Soyutlama CÃ¼mlesi

> **Dependency Injection**, â€œbileÅŸenlerin baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± kendilerinin deÄŸil, frameworkâ€™Ã¼n yÃ¶netmesiâ€ prensibidir.
>
> Angular, bu mekanizma sayesinde componentâ€™leri â€œUI katmanÄ±â€, serviceâ€™leri ise â€œiÅŸ mantÄ±ÄŸÄ± katmanÄ±â€ olarak ayÄ±rÄ±r.
> BÃ¶ylece kod modÃ¼ler, yeniden kullanÄ±labilir ve test edilebilir hale gelir.

---









# 2) privededIn nedir

MÃ¼kemmel nokta yakaladÄ±n ğŸ¯
`@Injectable({ providedIn: 'root' })` kÄ±smÄ± aslÄ±nda Angularâ€™Ä±n **dependency injection kapsamÄ±nÄ± (scope)** yÃ¶neten en kritik yapÄ± taÅŸÄ±dÄ±r.
Bunu Ã¶nce kÄ±sa, sonra kavramsal biÃ§imde aÃ§Ä±klayayÄ±m ğŸ‘‡

---

## ğŸ§© `providedIn` Nedir?

ğŸ“˜ **TanÄ±m:**
`providedIn`, Angularâ€™a **servisin hangi scopeâ€™ta (kapsamda)** saÄŸlanacaÄŸÄ±nÄ± sÃ¶yler.
Yani â€œbu service nerede ve ne kadar sÃ¼reyle yaÅŸasÄ±n?â€ sorusunun cevabÄ±dÄ±r.

```ts
@Injectable({
  providedIn: 'root'
})
export class LoggerService { ... }
```

Bu Ã¶rnekte:

* Angular uygulamasÄ± baÅŸlarken **tek bir `LoggerService` instanceâ€™Ä±** oluÅŸturur.
* Uygulama boyunca tÃ¼m componentâ€™ler aynÄ± instanceâ€™Ä± paylaÅŸÄ±r.
* Yani bu service **singleton (tekil)** davranÄ±r.

---

## âš™ï¸ 1. `providedIn` DeÄŸerleri ve FarklarÄ±

| DeÄŸer                    | Kapsam                              | DavranÄ±ÅŸ                                     | KullanÄ±m Durumu                               |
| ------------------------ | ----------------------------------- | -------------------------------------------- | --------------------------------------------- |
| `'root'`                 | Global (tÃ¼m uygulama)               | Singleton â€” tÃ¼m app boyunca tek instance     | En yaygÄ±n kullanÄ±m (default)                  |
| `'platform'`             | Angular platformu genelinde         | AynÄ± tarayÄ±cÄ± sekmesinde paylaÅŸÄ±lan instance | Microfrontend veya platform dÃ¼zeyi servisler  |
| `'any'`                  | Lazy load modÃ¼l baÅŸÄ±na bir instance | Her modÃ¼l kendi servisini Ã¼retir             | ModÃ¼l izolasyonu gereken durumlar             |
| `providedIn: SomeModule` | Belirli modÃ¼le Ã¶zel                 | Sadece o modÃ¼l yÃ¼klendiÄŸinde oluÅŸturulur     | Lazy load modÃ¼llerde servis baÅŸÄ±na kapsÃ¼lleme |

---

## ğŸ’¡ Ã–rnek: ModÃ¼l BazlÄ± Servis

```ts
@Injectable({
  providedIn: SomeFeatureModule
})
export class FeatureService { ... }
```

Bu durumda `FeatureService`, sadece `SomeFeatureModule` yÃ¼klendiÄŸinde oluÅŸturulur.
BaÅŸka modÃ¼ller bu servisi gÃ¶remez.

---

## ğŸ§  Kavramsal Soyutlama

> `providedIn`, servisin **yaÅŸam alanÄ±nÄ± (lifetime)** ve **gÃ¶rÃ¼nÃ¼rlÃ¼k sÄ±nÄ±rÄ±nÄ± (visibility scope)** tanÄ±mlar.
>
> * `'root'` â†’ tÃ¼m uygulamaya aÃ§Ä±k tek beyin (global singleton)
> * `'any'` â†’ her modÃ¼l kendi beynine sahip (modÃ¼ler baÄŸÄ±msÄ±zlÄ±k)
> * `SomeModule` â†’ sadece belirli modÃ¼le Ã¶zel (lazy loading uyumlu)

---

## âœ… Best Practice

| Durum                            | KullanÄ±m                                          |
| -------------------------------- | ------------------------------------------------- |
| KÃ¼Ã§Ã¼k / orta Ã¶lÃ§ekli uygulamalar | `providedIn: 'root'` (global singleton)           |
| BÃ¼yÃ¼k, modÃ¼ler uygulamalar       | `providedIn: 'any'` veya `providedIn: ModuleName` |
| Microfrontend yapÄ±lar            | `providedIn: 'platform'`                          |

---

## Ã–zet

> ```ts
> @Injectable({
>   providedIn: 'root'
> })
> ```
>
> * `providedIn`, servisin **nerede (hangi kapsamda)** Angular tarafÄ±ndan saÄŸlanacaÄŸÄ±nÄ± belirler.
> * `'root'` â†’ tÃ¼m uygulama boyunca **tek instance** oluÅŸturur (singleton pattern).
> * Bu, servislerin elle `providers` dizisine eklenmesine gerek bÄ±rakmaz ve en modern (best practice) yÃ¶ntemdir.

---




