
# 1) Lifecycle Hooks nedir, hangi problemi cozer, nasil kullanilir

## ğŸ§© 1. Lifecycle Hooks Nedir?

ğŸ“˜ **TanÄ±m:**
**Lifecycle Hooks**, Angular componentâ€™lerinin yaÅŸam dÃ¶ngÃ¼sÃ¼nde (oluÅŸturulma, gÃ¼ncellenme, yok edilme gibi aÅŸamalarda) belirli noktalarda **otomatik olarak Ã§aÄŸrÄ±lan Ã¶zel metotlardÄ±r.**

> BaÅŸka bir deyiÅŸle:
> Angular her component iÃ§in â€œyaÅŸam olaylarÄ±â€ Ã¼retir,
> ve sen bu olaylara â€œhookâ€ (kanca) takarak o anlarda Ã¶zel iÅŸlemler yapabilirsin.

---

## ğŸ¯ 2. Hangi Problemi Ã‡Ã¶zer?

Angular componentâ€™leri sadece HTML ve veriden ibaret deÄŸildir â€”
arka planda:

* DOMâ€™a eklenir (`create`),
* Input deÄŸerleri gÃ¼ncellenir (`update`),
* DOMâ€™dan kaldÄ±rÄ±lÄ±r (`destroy`).

EÄŸer bu aÅŸamalarda:

* APIâ€™den veri Ã§ekmek,
* log kaydÄ± tutmak,
* event listener eklemek/kaldÄ±rmak
  gibi iÅŸlemler yapman gerekiyorsa, **Lifecycle Hooks** kullanÄ±rsÄ±n.

Yani problem ÅŸudur:

> â€œComponentâ€™in ne zaman oluÅŸtuÄŸunu, gÃ¼ncellendiÄŸini veya silindiÄŸini nereden bileceÄŸim?â€
> **Cevap:** Angular bunu senin yerine yÃ¶netir â€” sadece doÄŸru hookâ€™a â€œkanca atarsÄ±nâ€.

---

## âš™ï¸ 3. En Temel Lifecycle Hooks (ve Ne Zaman Ã‡alÄ±ÅŸÄ±rlar)

| Hook                | Ne Zaman Ã‡alÄ±ÅŸÄ±r?                                                                    | Ne Ä°Ã§in KullanÄ±lÄ±r?                                                |
| ------------------- | ------------------------------------------------------------------------------------ | ------------------------------------------------------------------ |
| `ngOnInit()`        | Component ilk kez oluÅŸturulduÄŸunda (constructorâ€™dan sonra, view render olmadan Ã¶nce) | BaÅŸlangÄ±Ã§ta veri Ã§ekmek, state hazÄ±rlamak                          |
| `ngOnChanges()`     | `@Input()` ile gelen veri deÄŸiÅŸtiÄŸinde                                               | Parentâ€™tan gelen input deÄŸiÅŸimini izlemek                          |
| `ngDoCheck()`       | Angular deÄŸiÅŸiklik kontrolÃ¼ (change detection) sÄ±rasÄ±nda                             | Ã–zelleÅŸtirilmiÅŸ deÄŸiÅŸiklik kontrolÃ¼                                |
| `ngAfterViewInit()` | Componentâ€™in view (HTML) tamamen render edildiÄŸinde                                  | DOM eriÅŸimi gerektiren iÅŸlemler                                    |
| `ngOnDestroy()`     | Component DOMâ€™dan kaldÄ±rÄ±lÄ±rken                                                      | Temizlik: abonelik iptali, timer durdurma, event listener kaldÄ±rma |

---

## ğŸ’¡ 4. En SÄ±k KullanÄ±lan 3 Hookâ€™la Basit Ã–rnek

### ğŸ§± a) `ngOnInit()` â†’ â€œComponent oluÅŸturulduÄŸunda bir kez Ã§alÄ±ÅŸÄ±râ€

**app.component.ts**

```ts
export class AppComponent implements OnInit {
  message = '';

  ngOnInit() {
    this.message = 'Component yÃ¼klendi!';
    console.log('ngOnInit tetiklendi');
  }
}
```

**app.component.html**

```html
<p>{{ message }}</p>
```

ğŸŸ¢ **AÃ§Ä±klama:**
Angular, componentâ€™i ilk kez oluÅŸturduÄŸunda `ngOnInit()` bir kez Ã§aÄŸrÄ±lÄ±r.
Bu yÃ¼zden **API istekleri** veya **ilk yÃ¼kleme iÅŸlemleri** genellikle burada yapÄ±lÄ±r.

> NOT: Sayfa F5 ile yenilendiginde Angular sifirdan baslamis gibi yeniden ayaga kalkar ve componentler bir daha yuklenir. Dolayisiyla her F5 atildiginda o sayfadaki componentlere ait ngOnInit tekrar calisir.
---

### âš™ï¸ b) `ngOnChanges()` â†’ â€œParentâ€™tan gelen input deÄŸiÅŸtiÄŸinde tetiklenirâ€

**child.component.ts**

```ts
import { Input, OnChanges, SimpleChanges } from '@angular/core';

export class ChildComponent implements OnChanges {
  @Input() data!: string;

  ngOnChanges(changes: SimpleChanges) {
    console.log('Yeni veri geldi:', changes['data'].currentValue);
  }
}
```

ğŸŸ¢ **AÃ§Ä±klama:**
Parentâ€™ta `data` deÄŸiÅŸtiÄŸinde Angular bu hookâ€™u Ã§aÄŸÄ±rÄ±r.
Yani â€œchild component, parentâ€™tan gelen yeni veriye tepki verir.â€

---

### ğŸ§¹ c) `ngOnDestroy()` â†’ â€œComponent kaldÄ±rÄ±lmadan hemen Ã¶nce Ã§alÄ±ÅŸÄ±râ€

**app.component.ts**

```ts
export class AppComponent implements OnDestroy {
  timer!: any;

  ngOnInit() {
    this.timer = setInterval(() => console.log('Ã§alÄ±ÅŸÄ±yor...'), 1000);
  }

  ngOnDestroy() {
    clearInterval(this.timer);
    console.log('Component yok edildi.');
  }
}
```

ğŸŸ¢ **AÃ§Ä±klama:**
`ngOnDestroy()` genelde temizlik (cleanup) iÃ§in kullanÄ±lÄ±r:

* `setInterval`, `subscribe`, `addEventListener` gibi kaynaklarÄ± serbest bÄ±rakmak.
  BÃ¶ylece **memory leak (bellek sÄ±zÄ±ntÄ±sÄ±)** Ã¶nlenir.

---

## ğŸ§  5. Best Practiceâ€™ler

| Prensip                                         | AÃ§Ä±klama                                                            |
| ----------------------------------------------- | ------------------------------------------------------------------- |
| **1. ngOnInit iÃ§inde veri Ã§ek**                 | Component hazÄ±r olduÄŸunda API Ã§aÄŸrÄ±sÄ± yap. Constructorâ€™da deÄŸil.    |
| **2. ngOnDestroyâ€™da cleanup yap**               | Subscriptions, timerâ€™lar, event listenerâ€™lar mutlaka temizlenmeli.  |
| **3. Gereksiz Hook kullanma**                   | Her hook ek bir lifecycle cost getirir, yalnÄ±zca gerekliyse kullan. |
| **4. ngOnChanges ile veri izleme**              | @Input() verileri deÄŸiÅŸiyorsa, stateâ€™i burada senkronize et.        |
| **5. Angularâ€™Ä±n kontrol akÄ±ÅŸÄ±na mÃ¼dahale etme** | DOMâ€™u erken eriÅŸme (ngOnInit Ã¶ncesi) hataya yol aÃ§abilir.           |

---

## ğŸ§© 6. Soyutlama CÃ¼mlesi

> **Lifecycle Hooks**, Angularâ€™daki componentâ€™lerin â€œyaÅŸam evrelerineâ€ baÄŸlanmanÄ± saÄŸlar.
>
> Componentâ€™in **doÄŸduÄŸu**, **deÄŸiÅŸtiÄŸi** veya **Ã¶ldÃ¼ÄŸÃ¼** anda Ã¶zel davranÄ±ÅŸlar tanÄ±mlayabilirsin.
> BÃ¶ylece Angularâ€™Ä±n otomatik yaÅŸam dÃ¶ngÃ¼sÃ¼ne â€œkancalarâ€ ekleyerek uygulamanÄ±n her aÅŸamasÄ±nda kontrol sahibi olursun.

---
