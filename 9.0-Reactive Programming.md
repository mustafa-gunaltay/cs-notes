

# 1) Reaktif Programlama nedir, hangi problemi cozer, nasil kullanilir ?

Harika, şimdi Angular dünyasındaki **Reactive Programlama (RxJS)** temellerini kavrayalım 👇

---

## 🧩 1. Reactive Programlama Nedir?

📘 **Tanım:**
Reactive programlama, **veri akışlarını (streams)** ve bu akışlardaki **değişimlere tepki vermeyi (react)** temel alan bir programlama paradigmasıdır.

> Yani “veri geldiğinde, değiştiğinde veya hata oluştuğunda ne yapılacağını” tanımlarsın;
> kodun sürekli beklemek yerine **reaktif (tepki veren)** hale gelir.

---

## 🎯 2. Hangi Problemi Çözer?

Klasik (imperatif) yaklaşımda:

* Değişkenin ne zaman güncelleneceğini bilemezsin.
* Kullanıcı etkileşimleri, HTTP istekleri, zamanlayıcılar gibi asenkron olayları yönetmek karmaşıklaşır.
* “Callback hell” veya “promise zincirleri” oluşur.

Reactive yaklaşım:

* **Veri bir “Observable stream” olarak akar**.
* **Subscriber (aboneler)** bu akışı dinler.
* Veri geldiğinde, hata oluştuğunda veya tamamlandığında **otomatik tepki** verilir.

💡 **Soyutlama:**

> Reactive = “Veri değişimini bekleme, ona tepki ver.”

---

## ⚙️ 3. Angular’da RxJS Neden Önemli?

Angular, **temelinde reaktif bir framework’tür**:

* HTTP istekleri (`HttpClient`) → `Observable` döner
* Form kontrolleri (`FormControl.valueChanges`) → `Observable` döner
* Route parametreleri (`ActivatedRoute.params`) → `Observable` döner
* Component lifecycle yönetimi → `RxJS` ile kolaylaşır

Yani Angular zaten Reactive Programlama’yı “çekirdeğinde” kullanır.

---

## 🧱 4. Basit RxJS Akışı (Core Kavramlar)

### 🔹 Observable – Veri kaynağı

Observable, “zaman içinde değer yayımlayan” bir yapıdır.

```ts
import { of } from 'rxjs';

const observable$ = of(1, 2, 3);

observable$.subscribe({
  next: (value) => console.log('Değer:', value),
  complete: () => console.log('Bitti')
});
```

🟢 Çıktı:

```
Değer: 1
Değer: 2
Değer: 3
Bitti
```

> `of()` → sabit veri akışı oluşturur.
> Gerçek hayatta bu HTTP isteği, kullanıcı girişi, form değişikliği gibi olabilir.

---

### 🔹 Operator – Veri akışını dönüştürür

RxJS, **pipe operatörleri** ile akışı dönüştürmene olanak tanır.

```ts
import { of, map, filter } from 'rxjs';

of(1, 2, 3, 4, 5)
  .pipe(
    filter(x => x % 2 === 0),
    map(x => x * 10)
  )
  .subscribe(result => console.log(result));
```

🟢 Çıktı:

```
20
40
```

> `filter()` → koşula göre veri süzer
> `map()` → veriyi dönüştürür

💡 **Soyutlama:**

> RxJS operatörleri, “veri akışının matematiksel filtreleri” gibidir.
> Tıpkı SQL’de `WHERE` ve `SELECT` gibi düşün.

---

## 🔁 5. Angular Üzerinden Gerçekçi Örnekler

### 🧩 Örnek 1 — HTTP isteğini reaktif dinlemek

```ts
// user.service.ts
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class UserService {
  constructor(private http: HttpClient) {}

  getUsers(): Observable<any> {
    return this.http.get('/api/users');
  }
}
```

```ts
// user.component.ts
import { Component, inject } from '@angular/core';
import { UserService } from './user.service';

@Component({
  selector: 'app-user',
  template: `<ul><li *ngFor="let user of users">{{ user.name }}</li></ul>`
})
export class UserComponent {
  private userService = inject(UserService);
  users: any[] = [];

  ngOnInit() {
    this.userService.getUsers().subscribe({
      next: data => (this.users = data),
      error: err => console.error('Hata:', err)
    });
  }
}
```

🟢 **Açıklama:**

* `HttpClient.get()` bir **Observable** döner.
* `subscribe()` ile bu akış dinlenir.
* Sunucudan veri geldiğinde `users` güncellenir → View otomatik yenilenir.

---

### 🧩 Örnek 2 — Form değişikliklerini dinlemek

```ts
import { Component } from '@angular/core';
import { FormControl } from '@angular/forms';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';

@Component({
  selector: 'app-search',
  template: `<input [formControl]="search" placeholder="Ara...">`
})
export class SearchComponent {
  search = new FormControl('');

  ngOnInit() {
    this.search.valueChanges
      .pipe(
        debounceTime(300),         // 300 ms bekle
        distinctUntilChanged()     // Aynı değer tekrarlanmasın
      )
      .subscribe(value => console.log('Arama:', value));
  }
}
```

🟢 **Açıklama:**

* `FormControl.valueChanges` → Observable döndürür.
* Kullanıcı yazdıkça yeni değerler akar.
* `debounceTime` → aşırı istekleri engeller (performans)
* `distinctUntilChanged` → aynı kelimeyi tekrar işlemez

💡 **Soyutlama:**

> Bu yapı, “gerçek zamanlı kullanıcı etkileşimlerinde veri akışını kontrol etmenin” Angular’daki en yaygın yolu.

---

## ✅ 6. Best Practice Özeti

| Prensip                                             | Açıklama                                                                                |                                                |
| --------------------------------------------------- | --------------------------------------------------------------------------------------- | ---------------------------------------------- |
| **1. Observable → tek bilgi kaynağı olsun**         | Component içi state ve servis verisini tek akıştan yönlendir.                           |                                                |
| **2. Pipe operatörlerini kullan**                   | `map`, `filter`, `switchMap`, `debounceTime` gibi operatörlerle side effect’leri azalt. |                                                |
| **3. Subscription yönetimini unutma**               | `takeUntil`, `async pipe` veya `Subscription.unsubscribe()` kullan.                     |                                                |
| **4. async pipe tercih et**                         | Template içinde `                                                                       | async` ile otomatik subscribe/unsubscribe yap. |
| **5. Subject ve BehaviorSubject’i dikkatli kullan** | Componentler arası veri paylaşımı için servis içinde tanımla.                           |                                                |

---

## 💡 Soyutlama Cümlesi

> **Reactive Programlama**, “veri akışına tepki veren düşünme biçimidir.”
> Angular’da RxJS, bu akışları yönetmenin ve bileşenleri senkron tutmanın doğal yoludur.
> Böylece UI, veri değişimlerine *otomatik olarak tepki verir* — *imperatif olarak güncellenmez.*

---