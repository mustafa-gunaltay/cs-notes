

# 1)


## 🧩 **5️⃣ Zincir & Derin İletişim: “Forwarding” ve Bubbling**

### 📘 1. Kavramsal Tanım

**Bubbling/Forwarding**, hiyerarşide derinde (torun/grandchild) oluşan bir olayı **ara component(ler)** üzerinden **üst bileşene** taşımaktır.
Alt komponent **işi yapar**, ara komponent **olayı iletir**, üst komponent **karar/iş mantığını** yürütür.

> 🔹 **Soyut tanım:** “Derindeki sinyali, katmanlardan geçirip en üste ilet.”

---

### ⚙️ 2. Temel Örnek — Grandchild → Child → Parent

**grandchild.component.ts**

```ts
import { Component, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'app-grandchild',
  template: `<button (click)="save()">Kaydet</button>`
})
export class GrandchildComponent {
  @Output() saved = new EventEmitter<number>();

  save() {
    // Örnek payload: yeni kaydedilen kaynağın ID’si
    this.saved.emit(42);
  }
}
```

**child.component.ts**

```ts
import { Component, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `<app-grandchild (saved)="onGrandchildSaved($event)"></app-grandchild>`
})
export class ChildComponent {
  @Output() saved = new EventEmitter<number>();

  onGrandchildSaved(id: number) {
    // Forwarding: gelen olayı üst seviyeye tekrar yayınla
    this.saved.emit(id);
  }
}
```

**parent.component.html**

```html
<app-child (saved)="onDeepSaved($event)"></app-child>
```

**parent.component.ts**

```ts
onDeepSaved(id: number) {
  // En üstte nihai aksiyon
  console.log('Torundan gelen kayıt ID:', id);
}
```

🧠 **Ne oldu?**
`Grandchild.saved` → `Child.onGrandchildSaved` → `Child.saved.emit` → `(saved)` Parent’ta yakalandı.
Ara komponent **iş mantığı ekleyebilir** (ör. map/validate) ya da sadece **iletebilir**.

---

### 🔁 3. Alternatif: Servis Üzerinden Yayın (Siblings/Dağıtık Hiyerarşi)

Kardeş componentler veya çok uzak akrabalarda **servis + Subject/BehaviorSubject** ile iletişim kurmak daha sağlıklıdır.

**events.service.ts**

```ts
import { Injectable } from '@angular/core';
import { Subject } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class EventsService {
  private savedSubject = new Subject<number>();
  saved$ = this.savedSubject.asObservable();

  emitSaved(id: number) {
    this.savedSubject.next(id);
  }
}
```

**grandchild.component.ts**

```ts
constructor(private events: EventsService) {}
save() { this.events.emitSaved(42); }
```

**parent.component.ts**

```ts
constructor(private events: EventsService) {}
ngOnInit() {
  this.events.saved$.subscribe(id => this.onDeepSaved(id));
}
```

✅ Avantaj: Hiyerarşi bağımlılığını azaltır, karmaşık yönlendirmelerde ölçeklenir.

---

### ⚡ 4. Best Practice’ler

| Prensip                                        | Neden?                                                     |
| ---------------------------------------------- | ---------------------------------------------------------- |
| **1. Basit hiyerarşide forwarding kullan**     | 1–2 katmanda anlaşılır ve hızlıdır.                        |
| **2. Dağıtık/kardeş iletişimde servis kullan** | Hiyerarşik bağlamı gevşetir, test edilebilirliği artırır.  |
| **3. Payload’u anlamlı tasarla**               | `id`, `action`, `meta` gibi tipli (interface) veri gönder. |
| **4. İsimlendirmeyi fiil kipinde tut**         | `saved`, `deleted`, `selected` → niyet netliği.            |
| **5. Stateless child tercih et**               | Child sadece olay yayar, karar parent’ta verilir.          |

---

### 💡 Soyutlama Cümlesi

> **Forwarding**, derindeki olayları katmanlardan **yukarı doğru** taşır;
> basit hiyerarşide @Output zinciri yeterliyken, dağıtık senaryolarda **servis tabanlı yayın** (Subject) daha temiz ve ölçeklenebilir bir çözümdür.
