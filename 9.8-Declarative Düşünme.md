

# 1) 


## ⚙️ **8️⃣ Declarative Düşünme**

### 📘 1. Kavramsal Tanım

**Imperatif programlama**:

> “Ne yapacağını adım adım anlat.”
> Örneğin:

```ts
const numbers = [1, 2, 3];
const doubled: number[] = [];
for (const n of numbers) {
  doubled.push(n * 2);
}
console.log(doubled);
```

**Deklaratif (bildirimsel) programlama**:

> “Ne yapılması gerektiğini söyle, nasıl yapılacağını sistem çözsün.”
> Örneğin:

```ts
const numbers = [1, 2, 3];
const doubled = numbers.map(n => n * 2);
console.log(doubled);
```

💡 **Soyut tanım:**

> “Olay gerçekleştiğinde ne olacağını bildir, akışı kendisi yönetsin.”

---

### ⚡ 2. Reaktif Programlamada Deklaratif Yaklaşım

Reaktif sistemlerde “zaman ve olay yönetimi” de bildirimsel hale gelir.
Sen sadece **hangi olay gerçekleştiğinde ne yapılacağını** söylersin —
zamanlamayı, sıralamayı, tetiklemeyi **RxJS operatörleri** halleder.

```ts
this.searchControl.valueChanges
  .pipe(
    debounceTime(300),
    filter(text => text.length > 2),
    switchMap(text => this.api.search(text))
  )
  .subscribe(results => this.results = results);
```

🔍 Burada sen:

* **“Kullanıcı yazmayı bıraktıktan 300ms sonra, 2 karakterden uzun kelimeleri ara”** diyorsun,
* Ama **“nasıl zamanlanacağını”**, **“kaç thread kullanılacağını”** veya **“eşzamanlılığı”** tarif etmiyorsun.

Hepsini **reaktif sistem yönetiyor.**

---

### 🧠 3. Deklaratif Düşüncenin Faydaları

| Faydalar                      | Açıklama                                                                                   |
| ----------------------------- | ------------------------------------------------------------------------------------------ |
| **Az kod, daha çok anlam**    | Akışın “ne zaman, neye tepki vereceği” açıkça görünür.                                     |
| **Zaman yönetimi soyutlanır** | `debounceTime`, `switchMap`, `combineLatest` gibi operatörler zaman ve sıralamayı yönetir. |
| **Yüksek okunabilirlik**      | Kod, “ne yapacağını” açıkça anlatır.                                                       |
| **Kolay test edilebilirlik**  | Akışlar izole çalıştığından birim test kolaylaşır.                                         |

---

### 💻 4. Gerçek Hayat Örneği — Arama Kutusu

Imperatif yaklaşım:

```ts
onInputChange(event: any) {
  clearTimeout(this.timer);
  const value = event.target.value;
  this.timer = setTimeout(() => {
    if (value.length > 2) this.api.search(value);
  }, 300);
}
```

Deklaratif yaklaşım:

```ts
this.searchControl.valueChanges
  .pipe(
    debounceTime(300),
    filter(text => text.length > 2),
    switchMap(text => this.api.search(text))
  )
  .subscribe();
```

🧩 **Sonuç:** Aynı işlev, daha az kod — ama daha açık **“ne zaman ve neye tepki verileceği”** mantığı.

---

### ✅ 5. Best Practice

| Prensip                                                   | Açıklama                                                        |
| --------------------------------------------------------- | --------------------------------------------------------------- |
| **1. “Nasıl” değil, “ne zaman / ne olursa” odaklı düşün** | Reaktif sistemde sıralama değil, olayın kendisi önemlidir.      |
| **2. Pipe zincirlerini davranışa göre kur**               | Operatör zinciri, olay akışını tanımlar.                        |
| **3. State yönetimini akış temelli tasarla**              | Component’teki state, akışın sonucu olmalıdır.                  |
| **4. Kod akışı yerine veri akışını oku**                  | “Ne yapıyor?” yerine “hangi olaya tepki veriyor?” sorusunu sor. |

---

### 💡 Soyutlama Cümlesi

> Deklaratif düşünme, “kontrol etmek” yerine “bildirmek”tir.
> Akışın *nasıl çalışacağını* değil, *ne zaman ve neye tepki vereceğini* söylersin.
> Böylece sistem, insan aklının yönetemeyeceği karmaşık zaman sıralarını kendisi yönetir.

---

