

# 1) 


## âš™ï¸ **8ï¸âƒ£ Declarative DÃ¼ÅŸÃ¼nme**

### ğŸ“˜ 1. Kavramsal TanÄ±m

**Imperatif programlama**:

> â€œNe yapacaÄŸÄ±nÄ± adÄ±m adÄ±m anlat.â€
> Ã–rneÄŸin:

```ts
const numbers = [1, 2, 3];
const doubled: number[] = [];
for (const n of numbers) {
  doubled.push(n * 2);
}
console.log(doubled);
```

**Deklaratif (bildirimsel) programlama**:

> â€œNe yapÄ±lmasÄ± gerektiÄŸini sÃ¶yle, nasÄ±l yapÄ±lacaÄŸÄ±nÄ± sistem Ã§Ã¶zsÃ¼n.â€
> Ã–rneÄŸin:

```ts
const numbers = [1, 2, 3];
const doubled = numbers.map(n => n * 2);
console.log(doubled);
```

ğŸ’¡ **Soyut tanÄ±m:**

> â€œOlay gerÃ§ekleÅŸtiÄŸinde ne olacaÄŸÄ±nÄ± bildir, akÄ±ÅŸÄ± kendisi yÃ¶netsin.â€

---

### âš¡ 2. Reaktif Programlamada Deklaratif YaklaÅŸÄ±m

Reaktif sistemlerde â€œzaman ve olay yÃ¶netimiâ€ de bildirimsel hale gelir.
Sen sadece **hangi olay gerÃ§ekleÅŸtiÄŸinde ne yapÄ±lacaÄŸÄ±nÄ±** sÃ¶ylersin â€”
zamanlamayÄ±, sÄ±ralamayÄ±, tetiklemeyi **RxJS operatÃ¶rleri** halleder.

```ts
this.searchControl.valueChanges
  .pipe(
    debounceTime(300),
    filter(text => text.length > 2),
    switchMap(text => this.api.search(text))
  )
  .subscribe(results => this.results = results);
```

ğŸ” Burada sen:

* **â€œKullanÄ±cÄ± yazmayÄ± bÄ±raktÄ±ktan 300ms sonra, 2 karakterden uzun kelimeleri araâ€** diyorsun,
* Ama **â€œnasÄ±l zamanlanacaÄŸÄ±nÄ±â€**, **â€œkaÃ§ thread kullanÄ±lacaÄŸÄ±nÄ±â€** veya **â€œeÅŸzamanlÄ±lÄ±ÄŸÄ±â€** tarif etmiyorsun.

Hepsini **reaktif sistem yÃ¶netiyor.**

---

### ğŸ§  3. Deklaratif DÃ¼ÅŸÃ¼ncenin FaydalarÄ±

| Faydalar                      | AÃ§Ä±klama                                                                                   |
| ----------------------------- | ------------------------------------------------------------------------------------------ |
| **Az kod, daha Ã§ok anlam**    | AkÄ±ÅŸÄ±n â€œne zaman, neye tepki vereceÄŸiâ€ aÃ§Ä±kÃ§a gÃ¶rÃ¼nÃ¼r.                                     |
| **Zaman yÃ¶netimi soyutlanÄ±r** | `debounceTime`, `switchMap`, `combineLatest` gibi operatÃ¶rler zaman ve sÄ±ralamayÄ± yÃ¶netir. |
| **YÃ¼ksek okunabilirlik**      | Kod, â€œne yapacaÄŸÄ±nÄ±â€ aÃ§Ä±kÃ§a anlatÄ±r.                                                       |
| **Kolay test edilebilirlik**  | AkÄ±ÅŸlar izole Ã§alÄ±ÅŸtÄ±ÄŸÄ±ndan birim test kolaylaÅŸÄ±r.                                         |

---

### ğŸ’» 4. GerÃ§ek Hayat Ã–rneÄŸi â€” Arama Kutusu

Imperatif yaklaÅŸÄ±m:

```ts
onInputChange(event: any) {
  clearTimeout(this.timer);
  const value = event.target.value;
  this.timer = setTimeout(() => {
    if (value.length > 2) this.api.search(value);
  }, 300);
}
```

Deklaratif yaklaÅŸÄ±m:

```ts
this.searchControl.valueChanges
  .pipe(
    debounceTime(300),
    filter(text => text.length > 2),
    switchMap(text => this.api.search(text))
  )
  .subscribe();
```

ğŸ§© **SonuÃ§:** AynÄ± iÅŸlev, daha az kod â€” ama daha aÃ§Ä±k **â€œne zaman ve neye tepki verileceÄŸiâ€** mantÄ±ÄŸÄ±.

---

### âœ… 5. Best Practice

| Prensip                                                   | AÃ§Ä±klama                                                        |
| --------------------------------------------------------- | --------------------------------------------------------------- |
| **1. â€œNasÄ±lâ€ deÄŸil, â€œne zaman / ne olursaâ€ odaklÄ± dÃ¼ÅŸÃ¼n** | Reaktif sistemde sÄ±ralama deÄŸil, olayÄ±n kendisi Ã¶nemlidir.      |
| **2. Pipe zincirlerini davranÄ±ÅŸa gÃ¶re kur**               | OperatÃ¶r zinciri, olay akÄ±ÅŸÄ±nÄ± tanÄ±mlar.                        |
| **3. State yÃ¶netimini akÄ±ÅŸ temelli tasarla**              | Componentâ€™teki state, akÄ±ÅŸÄ±n sonucu olmalÄ±dÄ±r.                  |
| **4. Kod akÄ±ÅŸÄ± yerine veri akÄ±ÅŸÄ±nÄ± oku**                  | â€œNe yapÄ±yor?â€ yerine â€œhangi olaya tepki veriyor?â€ sorusunu sor. |

---

### ğŸ’¡ Soyutlama CÃ¼mlesi

> Deklaratif dÃ¼ÅŸÃ¼nme, â€œkontrol etmekâ€ yerine â€œbildirmekâ€tir.
> AkÄ±ÅŸÄ±n *nasÄ±l Ã§alÄ±ÅŸacaÄŸÄ±nÄ±* deÄŸil, *ne zaman ve neye tepki vereceÄŸini* sÃ¶ylersin.
> BÃ¶ylece sistem, insan aklÄ±nÄ±n yÃ¶netemeyeceÄŸi karmaÅŸÄ±k zaman sÄ±ralarÄ±nÄ± kendisi yÃ¶netir.

---

