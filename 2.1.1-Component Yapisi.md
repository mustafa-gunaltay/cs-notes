
# 1) Component nedir, hangi problemi cozer, nasil kullanilir

## ğŸ§© 1. Component Nedir, Hangi Problemi Ã‡Ã¶zer?

### ğŸ”¹ Ne?

**Component (bileÅŸen)**, Angular uygulamasÄ±nÄ±n en kÃ¼Ã§Ã¼k â€œmantÄ±ksal ve gÃ¶rsel birimiâ€dir.
Yani hem **veriyi** (TypeScript), hem **gÃ¶rÃ¼nÃ¼mÃ¼** (HTML), hem de **stili** (CSS) bir arada barÄ±ndÄ±rÄ±r.

```
Component = (HTML + CSS + TypeScript) Ã¼Ã§lÃ¼sÃ¼nÃ¼n anlamlÄ± bir modÃ¼lÃ¼
```

ğŸ§  **Soyutlama:**
Bir â€œcomponentâ€, bir kullanÄ±cÄ± arayÃ¼zÃ¼ parÃ§asÄ±nÄ± **kapsÃ¼ller (encapsulate)**.
Yani sayfadaki her buton, kart, form veya menÃ¼ ayrÄ± bir component olabilir.

---

### ğŸ”¹ Hangi Problemi Ã‡Ã¶zer?

**Problem (Ã¶ncesi):**

* BÃ¼yÃ¼k web projelerinde HTML, JS, CSS iÃ§ iÃ§e geÃ§er.
* Kod tekrarlarÄ± olur; aynÄ± buton veya form farklÄ± yerlerde yeniden yazÄ±lÄ±r.
* BakÄ±m zorlaÅŸÄ±r, deÄŸiÅŸiklikler tÃ¼m sayfayÄ± bozar.

**Ã‡Ã¶zÃ¼m (component yaklaÅŸÄ±mÄ±):**

* Her UI parÃ§asÄ± *baÄŸÄ±msÄ±z* bir modÃ¼l olur.
* Kod, gÃ¶rÃ¼nÃ¼m ve stil **tek yerde kapsÃ¼llenmiÅŸ** olur.
* Component yeniden kullanÄ±labilir (reusable) hale gelir.

> Component yaklaÅŸÄ±mÄ±, â€œSeparation of Concernsâ€ (sorumluluk ayrÄ±mÄ±) ilkesini UI dÃ¼zeyine taÅŸÄ±r.
> - HTML, CSS ve JS'de her bir html sayfasinin **script** seklinde tanimlanmis bir JS dosyasi ve **styles** seklinde tanimlanmis bir CSS dosyasi oluyordu. HTML in icinde birden fazla bilesen oldugu dusunulurse her bir bilesenin fonksiyonalitesini (JS dosyasinda) ve gorunumunu (CSS dosyasinda) belirleyen kodlar ic ice gecmis sekilde olacakti.
>   - Component yaklasiminda ise her bir bilesenin kendine ait gorunumu (CSS) ve fonksiyonalitesi (TS) var

---

### ğŸ§© KÃ¼Ã§Ã¼k Ã–rnek â€“ â€œSelamâ€ Componentâ€™i

```
src/app/selam/
 â”œâ”€â”€ selam.component.ts     â†’ davranÄ±ÅŸ
 â”œâ”€â”€ selam.component.html   â†’ gÃ¶rÃ¼nÃ¼m
 â”œâ”€â”€ selam.component.css    â†’ stil
```

**selam.component.ts**

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-selam',
  templateUrl: './selam.component.html',
  styleUrls: ['./selam.component.css']
})
export class SelamComponent {
  isim = 'Mustafa';
}
```

**selam.component.html**

```html
<h2>Merhaba {{ isim }}!</h2>
```

**selam.component.css**

```css
h2 {
  color: steelblue;
}
```

**app.component.html**

```html
<app-selam></app-selam>
```

âœ… Bu ÅŸekilde â€œSelamâ€ bileÅŸeni, baÄŸÄ±msÄ±z bir yapÄ± haline geldi.
BaÅŸka sayfalarda da sadece `<app-selam></app-selam>` yazarak kullanÄ±labilir.

---

## ğŸ§± 2. @Component Decorator ve Best Practice Implementasyonu

### ğŸ”¹ Ne iÅŸe yarar?

`@Component` decoratorâ€™Ä±, Angularâ€™a â€œbu class bir bileÅŸendirâ€ bilgisini verir.
AynÄ± zamanda bu bileÅŸenin **HTML ÅŸablonunu, CSS stilini ve selector adÄ±nÄ±** baÄŸlar.

```ts
@Component({
  selector: 'app-selam',          // HTML'de kullanÄ±lacak isim
  templateUrl: './selam.component.html', // HTML dosyasÄ±
  styleUrls: ['./selam.component.css']   // CSS dosyasÄ±
})
```

> Yani @Component, Ã¼Ã§ katmanÄ± (HTML + CSS + TS) Angular ekosistemi iÃ§inde birbirine â€œtanÄ±tÄ±râ€.

---

### ğŸ”¹ Best Practice KurallarÄ±

| Kural                         | AÃ§Ä±klama                                                                                                   |
| ----------------------------- | ---------------------------------------------------------------------------------------------------------- |
| **1. Dosya AyrÄ±mÄ±**           | Her component kendi `.ts`, `.html`, `.css` dosyalarÄ±na sahip olmalÄ±. (AyrÄ± dosya = yÃ¼ksek okunabilirlik)   |
| **2. Selector standardÄ±**     | `app-` Ã¶neki kullanÄ±lmalÄ± (Ã¶rnek: `<app-login>`)                                                           |
| **3. Class adlandÄ±rmasÄ±**     | PascalCase + â€œComponentâ€ eki (Ã¶rnek: `LoginComponent`)                                                     |
| **4. Tek sorumluluk ilkesi**  | Her component sadece *bir iÅŸlev* gÃ¶rmeli. (Ã¶rnek: â€œLoginâ€ veya â€œNavbarâ€)                                   |
| **5. ModÃ¼lerlik**             | Component, gerektiÄŸinde baÅŸka modÃ¼ller altÄ±nda gruplanabilir.                                              |
| **6. Template temizliÄŸi**     | Template iÃ§inde fazla JS mantÄ±ÄŸÄ± olmamalÄ±; sadece veri baÄŸlama (`{{ }}`) yapÄ±lmalÄ±.                        |
| **7. Input/Output kullanÄ±mÄ±** | Componentâ€™ler arasÄ± iletiÅŸim iÃ§in property binding (`@Input`) veya event binding (`@Output`) kullanÄ±lmalÄ±. |

---

### ğŸ”¹ KÃ¼Ã§Ã¼k Ã–rnek â€“ Best Practice UygulamasÄ±

**profil.component.ts**

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-profil',
  templateUrl: './profil.component.html',
  styleUrls: ['./profil.component.css']
})
export class ProfilComponent {
  ad = 'Zeynep';
  yas = 27;
}
```

**profil.component.html**

```html
<div class="profil">
  <h3>{{ ad }}</h3>
  <p>YaÅŸ: {{ yas }}</p>
</div>
```

**profil.component.css**

```css
.profil {
  border: 1px solid #ccc;
  padding: 8px;
  border-radius: 4px;
}
```

**app.component.html**

```html
<app-profil></app-profil>
```

ğŸ§  **SonuÃ§:**
Angular component yapÄ±sÄ±, HTMLâ€“CSSâ€“TS Ã¼Ã§lÃ¼sÃ¼nÃ¼ modÃ¼ler, izole ve yeniden kullanÄ±labilir hale getirir.
`@Component` decorator ise bu Ã¼Ã§lÃ¼yÃ¼ frameworkâ€™e tanÄ±tarak **UI parÃ§alarÄ±nÄ±n birer â€œyaÅŸayan yapÄ± taÅŸÄ±â€** haline gelmesini saÄŸlar.

---










# 2) Selector


## ğŸ§© 1. TanÄ±m: `selector` Nedir?

`selector`, bir **componentâ€™in HTML iÃ§inde nasÄ±l Ã§aÄŸrÄ±lacaÄŸÄ±nÄ±** belirleyen etikettir.
Yani Angularâ€™a â€œbu bileÅŸen DOM iÃ§inde hangi isimle temsil edilecek?â€ bilgisini verir.

```ts
@Component({
  selector: 'app-selam',
  templateUrl: './selam.component.html',
  styleUrls: ['./selam.component.css']
})
export class SelamComponent {}
```

Buradaki `selector: 'app-selam'`, ÅŸu anlama gelir ğŸ‘‡

> â€œBu component, HTMLâ€™de `<app-selam></app-selam>` etiketiyle kullanÄ±labilir.â€

---

## âš™ï¸ 2. Problem ve Ã‡Ã¶zÃ¼m MantÄ±ÄŸÄ±

**Problem (Ã¶ncesi):**
Vanilla JS veya jQuery gibi teknolojilerde bir bileÅŸeni yeniden kullanmak iÃ§in:

* AynÄ± HTML kodunu farklÄ± yerlere kopyalaman gerekir.
* DavranÄ±ÅŸÄ± da ayrÄ± ayrÄ± JS ile baÄŸlarsÄ±n.

Bu hem tekrarlÄ± hem hataya aÃ§Ä±k bir yaklaÅŸÄ±mdÄ±r.

**Ã‡Ã¶zÃ¼m (Angularâ€™Ä±n yaklaÅŸÄ±mÄ±):**
Angularâ€™da bir bileÅŸen bir â€œcustom HTML etiketiâ€ haline gelir.
Bu sayede:

* UI bileÅŸenleri *etiket olarak yeniden kullanÄ±labilir*.
* Kod modÃ¼lerleÅŸir, tekrar azalÄ±r.

Ã–rnek:

```html
<!-- app.component.html -->
<h1>Dashboard</h1>
<app-selam></app-selam>  <!-- burada Ã§aÄŸrÄ±ldÄ± -->
```

Burada `<app-selam>` senin componentâ€™ini Ã§aÄŸÄ±rÄ±r â€” tÄ±pkÄ± `<div>` gibi ama Ã¶zelleÅŸtirilmiÅŸ bir HTML etiketi.

---

## ğŸ§  3. Selector TÃ¼rleri (Ä°leri Seviye Bilgi)

Angularâ€™da `selector` aslÄ±nda bir **CSS seÃ§icisi (CSS selector)** gibi Ã§alÄ±ÅŸÄ±r.
Yani sadece element ismi deÄŸil, **class** veya **attribute** ÅŸeklinde de tanÄ±mlanabilir.

| Selector TÃ¼rÃ¼         | Ã–rnek         | HTML KullanÄ±mÄ±              | AÃ§Ä±klama                                                       |
| --------------------- | ------------- | --------------------------- | -------------------------------------------------------------- |
| **Element (default)** | `'app-selam'` | `<app-selam></app-selam>`   | En yaygÄ±n kullanÄ±m â€” component bir HTML etiketi gibi davranÄ±r. |
| **Class**             | `'.selam'`    | `<div class="selam"></div>` | Component bir CSS classâ€™Ä±na baÄŸlanÄ±r.                          |
| **Attribute**         | `'[selam]'`   | `<div selam></div>`         | Component bir attribute (Ã¶zellik) gibi baÄŸlanÄ±r.               |

ğŸ’¡ Ancak **best practice** olarak Angularâ€™da **element tipi selector** (`app-xyz`) tercih edilir, Ã§Ã¼nkÃ¼:

* HTML semantiÄŸini bozmaz,
* okunabilirliÄŸi artÄ±rÄ±r,
* kod standardizasyonu saÄŸlar.

---

## ğŸ’¡ 4. Best Practice Ã–nerileri

| Kural                                 | AÃ§Ä±klama                                                                           |
| ------------------------------------- | ---------------------------------------------------------------------------------- |
| **1. app- prefix kullan**             | Proje Ã¶lÃ§eÄŸinde isim Ã§akÄ±ÅŸmalarÄ±nÄ± Ã¶nler. (`app-navbar`, `app-login` gibi)         |
| **2. Selector tekil olmalÄ±**          | AynÄ± selector ismini birden fazla component kullanmamalÄ±.                          |
| **3. ModÃ¼l bazÄ±nda anlamlÄ± isim ver** | `user-card`, `todo-item`, `auth-login` gibi semantik isimler kullan.               |
| **4. Angular CLI kullan**             | `ng generate component selam` komutu selectorâ€™u otomatik olarak `app-selam` yapar. |

---

## ğŸ§© 5. Mini Ã–rnek

**mesaj.component.ts**

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-mesaj',
  template: `<p>Bu bir mesaj bileÅŸenidir!</p>`
})
export class MesajComponent {}
```

**app.component.html**

```html
<h1>Uygulama BaÅŸlÄ±ÄŸÄ±</h1>
<app-mesaj></app-mesaj> <!-- component burada kullanÄ±ldÄ± -->
```

ğŸŸ¢ **TarayÄ±cÄ± Ã§Ä±ktÄ±sÄ±:**

```
Uygulama BaÅŸlÄ±ÄŸÄ±
Bu bir mesaj bileÅŸenidir!
```

---

### ğŸ§  Soyutlama CÃ¼mlesi

> `selector`, Angular bileÅŸeninin **HTML dÃ¼nyasÄ±ndaki kimliÄŸidir.**
> TarayÄ±cÄ±, o etiketi gÃ¶rdÃ¼ÄŸÃ¼nde hangi component classâ€™Ä±nÄ±n Ã§alÄ±ÅŸacaÄŸÄ±nÄ± bilir.
> Bu sayede componentâ€™ler **yeniden kullanÄ±labilir, modÃ¼ler UI parÃ§alarÄ±** haline gelir.

---





# Component Notlarim

- Angular'da sayfalar da baska component'ler iceren birer component'dir


- Harici bir component kutuphanesi kullanilmadiginda yani componentler'i kendimiz olusturdugumuzda aslinda HTML elemanlari kullanilarak kendimiz custom bir HTML elemani olusturmus oluruz
  - Ornegin
```ts
// todo-item.component.ts
@Component({
  selector: 'app-todo-item',  // â† Yeni HTML tag adÄ±
  standalone: true,
  templateUrl: './todo-item.component.html',
  styleUrls: ['./todo-item.component.css']
})
export class TodoItemComponent {
  @Input() todo!: Todo;
  @Output() toggle = new EventEmitter<string>();
}
```

```html
<!-- ArtÄ±k app-todo-item diye bir HTML elemanÄ±nÄ±z var! -->
<app-todo-item [todo]="myTodo" (toggle)="handleToggle($event)"></app-todo-item>
```

- Angular Route â€“ Component Yeniden OluÅŸma KurallarÄ±:

  1. FarklÄ± routeâ€™a geÃ§ince Ã¶nceki component **destroy** olur, geri dÃ¶nÃ¼nce **yeniden oluÅŸturulur â†’ `ngOnInit` tekrar Ã§alÄ±ÅŸÄ±r.**
  2. AynÄ± component kullanÄ±lÄ±yorsa (sadece param deÄŸiÅŸiyorsa) Angular **reuse eder**, `ngOnInit` **tekrar Ã§alÄ±ÅŸmaz** â†’ param deÄŸiÅŸimine `ActivatedRoute` ile **subscribe** et.
  3. Parentâ€“child yapÄ±sÄ±nda sadece **child component** yeniden oluÅŸur; parent sabit kalabilir.
  4. Liste durumu korunacaksa (filtre, scroll, vs.) stateâ€™i **serviste** veya **query param**larda tut.
