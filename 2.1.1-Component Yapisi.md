
# 1) Component nedir, hangi problemi cozer, nasil kullanilir

## 🧩 1. Component Nedir, Hangi Problemi Çözer?

### 🔹 Ne?

**Component (bileşen)**, Angular uygulamasının en küçük “mantıksal ve görsel birimi”dir.
Yani hem **veriyi** (TypeScript), hem **görünümü** (HTML), hem de **stili** (CSS) bir arada barındırır.

```
Component = (HTML + CSS + TypeScript) üçlüsünün anlamlı bir modülü
```

🧠 **Soyutlama:**
Bir “component”, bir kullanıcı arayüzü parçasını **kapsüller (encapsulate)**.
Yani sayfadaki her buton, kart, form veya menü ayrı bir component olabilir.

---

### 🔹 Hangi Problemi Çözer?

**Problem (öncesi):**

* Büyük web projelerinde HTML, JS, CSS iç içe geçer.
* Kod tekrarları olur; aynı buton veya form farklı yerlerde yeniden yazılır.
* Bakım zorlaşır, değişiklikler tüm sayfayı bozar.

**Çözüm (component yaklaşımı):**

* Her UI parçası *bağımsız* bir modül olur.
* Kod, görünüm ve stil **tek yerde kapsüllenmiş** olur.
* Component yeniden kullanılabilir (reusable) hale gelir.

> Component yaklaşımı, “Separation of Concerns” (sorumluluk ayrımı) ilkesini UI düzeyine taşır.
> - HTML, CSS ve JS'de her bir html sayfasinin **script** seklinde tanimlanmis bir JS dosyasi ve **styles** seklinde tanimlanmis bir CSS dosyasi oluyordu. HTML in icinde birden fazla bilesen oldugu dusunulurse her bir bilesenin fonksiyonalitesini (JS dosyasinda) ve gorunumunu (CSS dosyasinda) belirleyen kodlar ic ice gecmis sekilde olacakti.
>   - Component yaklasiminda ise her bir bilesenin kendine ait gorunumu (CSS) ve fonksiyonalitesi (TS) var

---

### 🧩 Küçük Örnek – “Selam” Component’i

```
src/app/selam/
 ├── selam.component.ts     → davranış
 ├── selam.component.html   → görünüm
 ├── selam.component.css    → stil
```

**selam.component.ts**

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-selam',
  templateUrl: './selam.component.html',
  styleUrls: ['./selam.component.css']
})
export class SelamComponent {
  isim = 'Mustafa';
}
```

**selam.component.html**

```html
<h2>Merhaba {{ isim }}!</h2>
```

**selam.component.css**

```css
h2 {
  color: steelblue;
}
```

**app.component.html**

```html
<app-selam></app-selam>
```

✅ Bu şekilde “Selam” bileşeni, bağımsız bir yapı haline geldi.
Başka sayfalarda da sadece `<app-selam></app-selam>` yazarak kullanılabilir.

---

## 🧱 2. @Component Decorator ve Best Practice Implementasyonu

### 🔹 Ne işe yarar?

`@Component` decorator’ı, Angular’a “bu class bir bileşendir” bilgisini verir.
Aynı zamanda bu bileşenin **HTML şablonunu, CSS stilini ve selector adını** bağlar.

```ts
@Component({
  selector: 'app-selam',          // HTML'de kullanılacak isim
  templateUrl: './selam.component.html', // HTML dosyası
  styleUrls: ['./selam.component.css']   // CSS dosyası
})
```

> Yani @Component, üç katmanı (HTML + CSS + TS) Angular ekosistemi içinde birbirine “tanıtır”.

---

### 🔹 Best Practice Kuralları

| Kural                         | Açıklama                                                                                                   |
| ----------------------------- | ---------------------------------------------------------------------------------------------------------- |
| **1. Dosya Ayrımı**           | Her component kendi `.ts`, `.html`, `.css` dosyalarına sahip olmalı. (Ayrı dosya = yüksek okunabilirlik)   |
| **2. Selector standardı**     | `app-` öneki kullanılmalı (örnek: `<app-login>`)                                                           |
| **3. Class adlandırması**     | PascalCase + “Component” eki (örnek: `LoginComponent`)                                                     |
| **4. Tek sorumluluk ilkesi**  | Her component sadece *bir işlev* görmeli. (örnek: “Login” veya “Navbar”)                                   |
| **5. Modülerlik**             | Component, gerektiğinde başka modüller altında gruplanabilir.                                              |
| **6. Template temizliği**     | Template içinde fazla JS mantığı olmamalı; sadece veri bağlama (`{{ }}`) yapılmalı.                        |
| **7. Input/Output kullanımı** | Component’ler arası iletişim için property binding (`@Input`) veya event binding (`@Output`) kullanılmalı. |

---

### 🔹 Küçük Örnek – Best Practice Uygulaması

**profil.component.ts**

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-profil',
  templateUrl: './profil.component.html',
  styleUrls: ['./profil.component.css']
})
export class ProfilComponent {
  ad = 'Zeynep';
  yas = 27;
}
```

**profil.component.html**

```html
<div class="profil">
  <h3>{{ ad }}</h3>
  <p>Yaş: {{ yas }}</p>
</div>
```

**profil.component.css**

```css
.profil {
  border: 1px solid #ccc;
  padding: 8px;
  border-radius: 4px;
}
```

**app.component.html**

```html
<app-profil></app-profil>
```

🧠 **Sonuç:**
Angular component yapısı, HTML–CSS–TS üçlüsünü modüler, izole ve yeniden kullanılabilir hale getirir.
`@Component` decorator ise bu üçlüyü framework’e tanıtarak **UI parçalarının birer “yaşayan yapı taşı”** haline gelmesini sağlar.

---










# 2) Selector


## 🧩 1. Tanım: `selector` Nedir?

`selector`, bir **component’in HTML içinde nasıl çağrılacağını** belirleyen etikettir.
Yani Angular’a “bu bileşen DOM içinde hangi isimle temsil edilecek?” bilgisini verir.

```ts
@Component({
  selector: 'app-selam',
  templateUrl: './selam.component.html',
  styleUrls: ['./selam.component.css']
})
export class SelamComponent {}
```

Buradaki `selector: 'app-selam'`, şu anlama gelir 👇

> “Bu component, HTML’de `<app-selam></app-selam>` etiketiyle kullanılabilir.”

---

## ⚙️ 2. Problem ve Çözüm Mantığı

**Problem (öncesi):**
Vanilla JS veya jQuery gibi teknolojilerde bir bileşeni yeniden kullanmak için:

* Aynı HTML kodunu farklı yerlere kopyalaman gerekir.
* Davranışı da ayrı ayrı JS ile bağlarsın.

Bu hem tekrarlı hem hataya açık bir yaklaşımdır.

**Çözüm (Angular’ın yaklaşımı):**
Angular’da bir bileşen bir “custom HTML etiketi” haline gelir.
Bu sayede:

* UI bileşenleri *etiket olarak yeniden kullanılabilir*.
* Kod modülerleşir, tekrar azalır.

Örnek:

```html
<!-- app.component.html -->
<h1>Dashboard</h1>
<app-selam></app-selam>  <!-- burada çağrıldı -->
```

Burada `<app-selam>` senin component’ini çağırır — tıpkı `<div>` gibi ama özelleştirilmiş bir HTML etiketi.

---

## 🧠 3. Selector Türleri (İleri Seviye Bilgi)

Angular’da `selector` aslında bir **CSS seçicisi (CSS selector)** gibi çalışır.
Yani sadece element ismi değil, **class** veya **attribute** şeklinde de tanımlanabilir.

| Selector Türü         | Örnek         | HTML Kullanımı              | Açıklama                                                       |
| --------------------- | ------------- | --------------------------- | -------------------------------------------------------------- |
| **Element (default)** | `'app-selam'` | `<app-selam></app-selam>`   | En yaygın kullanım — component bir HTML etiketi gibi davranır. |
| **Class**             | `'.selam'`    | `<div class="selam"></div>` | Component bir CSS class’ına bağlanır.                          |
| **Attribute**         | `'[selam]'`   | `<div selam></div>`         | Component bir attribute (özellik) gibi bağlanır.               |

💡 Ancak **best practice** olarak Angular’da **element tipi selector** (`app-xyz`) tercih edilir, çünkü:

* HTML semantiğini bozmaz,
* okunabilirliği artırır,
* kod standardizasyonu sağlar.

---

## 💡 4. Best Practice Önerileri

| Kural                                 | Açıklama                                                                           |
| ------------------------------------- | ---------------------------------------------------------------------------------- |
| **1. app- prefix kullan**             | Proje ölçeğinde isim çakışmalarını önler. (`app-navbar`, `app-login` gibi)         |
| **2. Selector tekil olmalı**          | Aynı selector ismini birden fazla component kullanmamalı.                          |
| **3. Modül bazında anlamlı isim ver** | `user-card`, `todo-item`, `auth-login` gibi semantik isimler kullan.               |
| **4. Angular CLI kullan**             | `ng generate component selam` komutu selector’u otomatik olarak `app-selam` yapar. |

---

## 🧩 5. Mini Örnek

**mesaj.component.ts**

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-mesaj',
  template: `<p>Bu bir mesaj bileşenidir!</p>`
})
export class MesajComponent {}
```

**app.component.html**

```html
<h1>Uygulama Başlığı</h1>
<app-mesaj></app-mesaj> <!-- component burada kullanıldı -->
```

🟢 **Tarayıcı çıktısı:**

```
Uygulama Başlığı
Bu bir mesaj bileşenidir!
```

---

### 🧠 Soyutlama Cümlesi

> `selector`, Angular bileşeninin **HTML dünyasındaki kimliğidir.**
> Tarayıcı, o etiketi gördüğünde hangi component class’ının çalışacağını bilir.
> Bu sayede component’ler **yeniden kullanılabilir, modüler UI parçaları** haline gelir.

---





# Component Notlarim

- Angular'da sayfalar da baska component'ler iceren birer component'dir


- Harici bir component kutuphanesi kullanilmadiginda yani componentler'i kendimiz olusturdugumuzda aslinda HTML elemanlari kullanilarak kendimiz custom bir HTML elemani olusturmus oluruz
  - Ornegin
```ts
// todo-item.component.ts
@Component({
  selector: 'app-todo-item',  // ← Yeni HTML tag adı
  standalone: true,
  templateUrl: './todo-item.component.html',
  styleUrls: ['./todo-item.component.css']
})
export class TodoItemComponent {
  @Input() todo!: Todo;
  @Output() toggle = new EventEmitter<string>();
}
```

```html
<!-- Artık app-todo-item diye bir HTML elemanınız var! -->
<app-todo-item [todo]="myTodo" (toggle)="handleToggle($event)"></app-todo-item>
```

- Angular Route – Component Yeniden Oluşma Kuralları:

  1. Farklı route’a geçince önceki component **destroy** olur, geri dönünce **yeniden oluşturulur → `ngOnInit` tekrar çalışır.**
  2. Aynı component kullanılıyorsa (sadece param değişiyorsa) Angular **reuse eder**, `ngOnInit` **tekrar çalışmaz** → param değişimine `ActivatedRoute` ile **subscribe** et.
  3. Parent–child yapısında sadece **child component** yeniden oluşur; parent sabit kalabilir.
  4. Liste durumu korunacaksa (filtre, scroll, vs.) state’i **serviste** veya **query param**larda tut.
